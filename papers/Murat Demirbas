Does The Cloud Need Stabilizing?

  The last decade has witnessed rapid proliferation of cloud computing. Whileeven the smallest distributed programs (with 3-5 actions) produce manyunanticipated error cases due to concurrency involved, it seems short of amiracle these web-services are able to operate at those vast scales. In thispaper, we explore the factors that contribute most to the high-availability ofcloud computing services and examine where self-stabilization could fit in thatpicture.

WPaxos: Wide Area Network Flexible Consensus

  WPaxos is a multileader Paxos protocol that provides low-latency andhigh-throughput consensus across wide-area network (WAN) deployments. WPaxosuses multileaders, and partitions the object-space among these multileaders.Unlike statically partitioned multiple Paxos deployments, WPaxos is able toadapt to the changing access locality through object stealing. Multipleconcurrent leaders coinciding in different zones steal ownership of objectsfrom each other using phase-1 of Paxos, and then use phase-2 to commitupdate-requests on these objects locally until they are stolen by otherleaders. To achieve fast phase-2 commits, WPaxos adopts the flexible quorumsidea in a novel manner, and appoints phase-2 acceptors to be close to theirrespective leaders. We implemented WPaxos and evaluated it on WAN deploymentsacross 5 AWS regions. The dynamic partitioning of the object-space and emphasison zone-local commits allow WPaxos to significantly outperform both partitionedPaxos deployments and leaderless Paxos approaches.

Monitoring Partially Synchronous Distributed Systems using SMT Solvers

  In this paper, we discuss the feasibility of monitoring partially synchronousdistributed systems to detect latent bugs, i.e., errors caused by concurrencyand race conditions among concurrent processes. We present a monitoringframework where we model both system constraints and latent bugs asSatisfiability Modulo Theories (SMT) formulas, and we detect the presence oflatent bugs using an SMT solver. We demonstrate the feasibility of ourframework using both synthetic applications where latent bugs occur at any timewith random probability and an application involving exclusive access to ashared resource with a subtle timing bug. We illustrate how the time requiredfor verification is affected by parameters such as communication frequency,latency, and clock skew. Our results show that our framework can be used forreal-life applications, and because our framework uses SMT solvers, the rangeof appropriate applications will increase as these solvers become moreefficient over time.

Optimistic Execution in Key-Value Store

  Limitations of CAP theorem imply that if availability is desired in thepresence of network partitions, one must sacrifice sequential consistency, aconsistency model that is more natural for system design. We focus on theproblem of what a designer should do if she has an algorithm that workscorrectly with sequential consistency but is faced with an underlying key-valuestore that provides a weaker (e.g., eventual or causal) consistency. We proposea detect-rollback based approach: The designer identifies a correctnesspredicate, say P , and continue to run the protocol, as our system monitors P .If P is violated (because the underlying key-value store provides a weakerconsistency), the system rolls back and resumes the computation at a statewhere P holds.  We evaluate this approach in the Voldemort key-value store. Our experimentswith deployment of Voldemort on Amazon AWS shows that using eventualconsistency with monitoring can provide 20 - 40% increase in throughput whencompared with sequential consistency. We also show that the overhead of themonitor itself is small (typically less than 8%) and the latency of detectingviolations is very low. For example, more than 99.9% violations are detected inless than 1 second.

Precision, Recall, and Sensitivity of Monitoring Partially Synchronous  Distributed Systems

  Runtime verification focuses on analyzing the execution of a given program bya monitor to determine if it is likely to violate its specifications. There isoften an impedance mismatch between the assumptions/model of the monitor andthat of the underlying program. This constitutes problems especially fordistributed systems, where the concept of current time and state are inherentlyuncertain. A monitor designed with asynchronous system model assumptions maycause false-positives for a program executing in a partially synchronoussystem: the monitor may flag a global predicate that does not actually occur inthe underlying system. A monitor designed with a partially synchronous systemmodel assumption may cause false negatives as well as false positives for aprogram executing in an environment where the bounds on partial synchronydiffer (albeit temporarily) from the monitor model assumptions.  In this paper we analyze the effects of the impedance mismatch between themonitor and the underlying program for the detection of conjunctive predicates.We find that there is a small interval where the monitor assumptions arehypersensitive to the underlying program environment. We provide analyticalderivations for this interval, and also provide simulation support forexploring the sensitivity of predicate detection to the impedance mismatchbetween the monitor and the program under a partially synchronous system.

Technical Report: Optimistic Execution in Key-Value Store

  Limitations of the CAP theorem imply that if availability is desired in thepresence of network partitions, one must sacrifice sequential consistency, aconsistency model that is more natural for system design. We focus on theproblem of what a designer should do if he/she has an algorithm that workscorrectly with sequential consistency but is faced with an underlying key-valuestore that provides a weaker (e.g., eventual or causal) consistency. We proposea detect-rollback based approach: The designer identifies a correctnesspredicate, say $P$, and continues to run the protocol, as our system monitors$P$. If $P$ is violated (because the underlying key-value store provides aweaker consistency), the system rolls back and resumes the computation at astate where $P$ holds.  We evaluate this approach with practical graph applications running on theVoldemort key-value store. Our experiments with deployment on Amazon AWS EC2instances shows that using eventual consistency with monitoring can provide a$50-80\%$ increase in throughput when compared with sequential consistency. Wealso show that the overhead of the monitoring itself is low (typically lessthan 4\%) and the latency of detecting violations is small. In particular, morethan $99.9\%$ of violations are detected in less than $50$ milliseconds inregional AWS networks, and in less than $5$ seconds in global AWS networks.

CausalSpartanX: Causal Consistency and Non-Blocking Read-Only  Transactions

  Causal consistency is an intermediate consistency model that can be achievedtogether with high availability and performance requirements even in presenceof network partitions. In the context of partitioned data stores, it has beenshown that implicit dependency tracking using timestamps is more efficient thanexplicit dependency tracking. Existing time-based solutions depend on monotonicpsychical clocks that are closely synchronized. These requirements make currentprotocols vulnerable to clock anomalies. In this paper, we propose a newtime-based algorithm, CausalSpartanX, that instead of physical clocks, utilizesHybrid Logical Clocks (HLCs). We show that using HLCs, without any overhead, wemake the system robust on physical clock anomalies. This improvement is moresignificant in the context of query amplification, where a single query resultsin multiple GET/PUT operations. We also show that CausalSpartanX decreases thevisibility latency for a given data item compared with existing time-basedapproaches. In turn, this reduces the completion time of collaborativeapplications where two clients accessing two different replicas edit same itemsof the data store. CausalSpartanX also provides causally consistent distributedread-only transactions. CausalSpartanX read-only transactions are non-blockingand require only one round of communication between the client and the servers.Also, the slowdowns of partitions that are unrelated to a transaction do notaffect the performance of the transaction. Like previous protocols,CausalSpartanX assumes that a given client does not access more than onereplica. We show that in presence of network partitions, this assumption (madein several other works) is essential if one were to provide causal consistencyas well as immediate availability to local updates.

