Non-Blocking Concurrent Imperative Programming with Session Types

  Concurrent C0 is an imperative programming language in the C family withsession-typed message-passing concurrency. The previously proposed semanticsimplements asynchronous (non-blocking) output; we extend it here withnon-blocking input. A key idea is to postpone message reception as much aspossible by interpreting receive commands as a request for a message. Weimplemented our ideas as a translation from a blocking intermediate language toa non-blocking language. Finally, we evaluated our techniques with severalbenchmark programs and show the results obtained. While the abstract measure ofspan always decreases (or remains unchanged), only a few of the examples reap apractical benefit.

Design and Implementation of Concurrent C0

  We describe Concurrent C0, a type-safe C-like language with contracts andsession-typed communication over channels. Concurrent C0 supports an operationcalled forwarding which allows channels to be combined in a well-defined way.The language's type system enables elegant expression of session types andmessage-passing concurrent programs. We provide a Go-based implementation withlanguage based optimizations that outperforms traditional message passingtechniques.

A Message-Passing Interpretation of Adjoint Logic

  We present a system of session types based on adjoint logic which generalizestandard binary session types. Our system allows us to uniformly captureseveral new behaviors in the space of asynchronous message-passingcommunication, including multicast, where a process sends a single message tomultiple clients, replicable services, which have multiple clients andreplicate themselves on-demand to handle requests from those clients, andcancellation, where a process discards a channel without communicating alongit. We provide session fidelity and deadlock-freedom results for this system,from which we then derive a logically justified form of garbage collection.

Higher-Order Pattern Complement and the Strict Lambda-Calculus

  We address the problem of complementing higher-order patterns withoutrepetitions of existential variables. Differently from the first-order case,the complement of a pattern cannot, in general, be described by a pattern, oreven by a finite set of patterns. We therefore generalize the simply-typedlambda-calculus to include an internal notion of strict function so that we candirectly express that a term must depend on a given variable. We show that, inthis more expressive calculus, finite sets of patterns without repeatedvariables are closed under complement and intersection. Our principalapplication is the transformational approach to negation in higher-order logicprograms.

On Equivalence and Canonical Forms in the LF Type Theory

  Decidability of definitional equality and conversion of terms into canonicalform play a central role in the meta-theory of a type-theoretic logicalframework. Most studies of definitional equality are based on a confluent,strongly-normalizing notion of reduction. Coquand has considered a differentapproach, directly proving the correctness of a practical equivalance algorithmbased on the shape of terms. Neither approach appears to scale well to richerlanguages with unit types or subtyping, and neither directly addresses theproblem of conversion to canonical.  In this paper we present a new, type-directed equivalence algorithm for theLF type theory that overcomes the weaknesses of previous approaches. Thealgorithm is practical, scales to richer languages, and yields a new notion ofcanonical form sufficient for adequate encodings of logical systems. Thealgorithm is proved complete by a Kripke-style logical relations argumentsimilar to that suggested by Coquand. Crucially, both the algorithm itself andthe logical relations rely only on the shapes of types, ignoring dependencieson terms.

The Bedwyr system for model checking over syntactic expressions

  Bedwyr is a generalization of logic programming that allows model checkingdirectly on syntactic expressions possibly containing bindings. This system,written in OCaml, is a direct implementation of two recent advances in thetheory of proof search. The first is centered on the fact that both finitesuccess and finite failure can be captured in the sequent calculus byincorporating inference rules for definitions that allow fixed points to beexplored. As a result, proof search in such a sequent calculus can capturesimple model checking problems as well as may and must behavior in operationalsemantics. The second is that higher-order abstract syntax is directlysupported using term-level $\lambda$-binders and the $\nabla$ quantifier. Thesefeatures allow reasoning directly on expressions containing bound variables.

A Linear Logic Programming Language for Concurrent Programming over  Graph Structures

  We have designed a new logic programming language called LM (Linear Meld) forprogramming graph-based algorithms in a declarative fashion. Our language isbased on linear logic, an expressive logical system where logical facts can beconsumed. Because LM integrates both classical and linear logic, LM tends to bemore expressive than other logic programming languages. LM programs arenaturally concurrent because facts are partitioned by nodes of a graph datastructure. Computation is performed at the node level while communicationhappens between connected nodes. In this paper, we present the syntax andoperational semantics of our language and illustrate its use through a numberof examples.

Intersections and Unions of Session Types

  Prior work has extended the deep, logical connection between the linearsequent calculus and session-typed message-passing concurrent computation withequi-recursive types and a natural notion of subtyping. In this paper, weextend this further by intersection and union types in order to expressmultiple behavioral properties of processes in a single type. We prove sessionfidelity and absence of deadlock and illustrate the expressive power of oursystem with some simple examples. We observe that we can represent internal andexternal choice by intersection and union, respectively, which was previouslysuggested by Padovani for a different language of session types motivated byoperational rather than logical concerns.

Parallel Complexity Analysis with Temporal Session Types

  We study the problem of parametric parallel complexity analysis ofconcurrent, message-passing programs. To make the analysis local andcompositional, it is based on a conservative extension of binary session types,which structure the type and direction of communication between processes andstand in a Curry-Howard correspondence with intuitionistic linear logic. Themain innovation is to enrich session types with the temporal modalities next($\bigcirc A$), always ($\Box A$), and eventually ($\Diamond A$), toadditionally prescribe the timing of the exchanged messages in a way that isprecise yet flexible. The resulting temporal session types uniformly expressproperties such as the message rate of a stream, the latency of a pipeline, theresponse time of a concurrent queue, or the span of a fork/join parallelprogram. The analysis is parametric in the cost model and the presentationfocuses on communication cost as a concrete example. The soundness of theanalysis is established by proofs of progress and type preservation using atimed multiset rewriting semantics. Representative examples illustrate thescope and usability of the approach.

Refinement Types for Logical Frameworks and Their Interpretation as  Proof Irrelevance

  Refinement types sharpen systems of simple and dependent types by offeringexpressive means to more precisely classify well-typed terms. We present asystem of refinement types for LF in the style of recent formulations whereonly canonical forms are well-typed. Both the usual LF rules and the rules fortype refinements are bidirectional, leading to a straightforward proof ofdecidability of typechecking even in the presence of intersection types.Because we insist on canonical forms, structural rules for subtyping can now bederived rather than being assumed as primitive. We illustrate the expressivepower of our system with examples and validate its design by demonstrating aprecise correspondence with traditional presentations of subtyping. Proofirrelevance provides a mechanism for selectively hiding the identities of termsin type theories. We show that LF refinement types can be interpreted aspredicates using proof irrelevance, establishing a uniform relationship betweentwo previously studied concepts in type theory. The interpretation and itscorrectness proof are surprisingly complex, lending support to the claim thatrefinement types are a fundamental construct rather than just a convenientsurface syntax for certain uses of proof irrelevance.

Work Analysis with Resource-Aware Session Types

  While there exist several successful techniques for supporting programmers inderiving static resource bounds for sequential code, analyzing the resourceusage of message-passing concurrent processes poses additional challenges. Tomeet these challenges, this article presents an analysis for staticallyderiving worst-case bounds on the total work performed by message-passingprocesses. To decompose interacting processes into components that can beanalyzed in isolation, the analysis is based on novel resource-aware sessiontypes, which describe protocols and resource contracts for inter-processcommunication. A key innovation is that both messages and processes carrypotential to share and amortize cost while communicating. To symbolicallyexpress resource usage in a setting without static data structures andintrinsic sizes, resource contracts describe bounds that are functions ofinteractions between processes. Resource-aware session types combine standardbinary session types and type-based amortized resource analysis in a lineartype system. This type system is formulated for a core session-type calculus ofthe language SILL and proved sound with respect to a multiset-based operationalcost semantics that tracks the total number of messages that are exchanged in asystem. The effectiveness of the analysis is demonstrated by analyzing standardexamples from amortized analysis and the literature on session types and by acomparative performance analysis of different concurrent programs implementingthe same interface.

Resource-Aware Session Types for Digital Contracts

  Programming digital contracts comes with unique challenges, which includeexpressing and enforcing protocols of interaction, controlling resource usage,and tracking linear assets. This article presents the type-theoretic foundationof Nomos, a programming language for digital contracts whose type systemaddresses the aforementioned domain-specific requirements. To express andenforce protocols, Nomos is based on shared binary session types rooted inlinear logic. To control resource usage, Nomos uses resource-aware sessiontypes and automatic amortized resource analysis, a type-based technique forinferring resource bounds. To track linear assets, Nomos employs a linear typesystem that prevents assets from being duplicated or discarded. The technicalcontribution is the design and soundness proof of Nomos' type system, whichintegrates shared session types and resource-aware session types with afunctional type system that supports automatic amortized resource analysis. Toevaluate Nomos' viability for digital contract development, we include a casestudy of several blockchain applications and demonstrate how theirvulnerabilities do not arise in corresponding Nomos applications. Inparticular, Nomos ensures that synthetic tokens implement their technicalstandard and prevents vulnerabilities due to violations of linearity,out-of-gas exceptions, or dependence on transaction ordering. To evaluateNomos' session-based design, we report on the performance of three digitalcontracts implemented in an existing prototype language.

Polarities & Focussing: a journey from Realisability to Automated  Reasoning

  This dissertation explores the roles of polarities and focussing in variousaspects of Computational Logic. These concepts play a key role in the theinterpretation of proofs as programs, a.k.a. the Curry-Howard correspondence,in the context of classical logic. Arising from linear logic, they allow theconstruction of meaningful semantics for cut-elimination in classical logic,some of which relate to the Call-by-Name and Call-by-Value disciplines offunctional programming. The first part of this dissertation provides anintroduction to these interpretations, highlighting the roles of polarities andfocussing. For instance: proofs of positive formulae provide structured data,while proofs of negative formulae consume such data; focussing allows thedescription of the interaction between the two kinds of proofs as purepattern-matching. This idea is pushed further in the second part of thisdissertation, and connected to realisability semantics, where the structureddata is interpreted algebraically, and the consumption of such data is modelledwith the use of an orthogonality relation. Most of this part has been proved inthe Coq proof assistant. Polarities and focussing were also introduced withapplications to logic programming in mind, where computation is proof-search.In the third part of this dissertation, we push this idea further by exploringthe roles that these concepts can play in other applications of proof-search,such as theorem proving and more particularly automated reasoning. We use theseconcepts to describe the main algorithm of SAT-solvers and SMT-solvers: DPLL.We then describe the implementation of a proof-search engine called Psyche. Itsarchitecture, based on the concept of focussing, offers a platform where smarttechniques from automated reasoning (or a user interface) can safely andtrustworthily be implemented via the use of an API.

