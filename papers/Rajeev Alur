Coinductive Proof Principles for Stochastic Processes

  We give an explicit coinduction principle for recursively-defined stochasticprocesses. The principle applies to any closed property, not just equality, andworks even when solutions are not unique. The rule encapsulates low-levelanalytic arguments, allowing reasoning about such processes at a higheralgebraic level. We illustrate the use of the rule in deriving properties of asimple coin-flip process.

Language to Specify Syntax-Guided Synthesis Problems

  We present a language to specify syntax guided synthesis (SyGuS) problems.Syntax guidance is a prominent theme in contemporary program synthesisapproaches, and SyGuS was first described in [1]. This paper describesconcretely the input format of a SyGuS solver.  [1] Rajeev Alur, Rastislav Bodik, Garvit Juniwal, Milo M. K. Martin, MukundRaghothaman, Sanjit A. Seshia, Rishabh Singh, Armando Solar-Lezama, EminaTorlak, and Abhishek Udupa. Syntax-guided synthesis. In FMCAD, pages 1--17,2013.

First-Order and Temporal Logics for Nested Words

  Nested words are a structured model of execution paths in proceduralprograms, reflecting their call and return nesting structure. Finite nestedwords also capture the structure of parse trees and other tree-structured data,such as XML. We provide new temporal logics for finite and infinite nestedwords, which are natural extensions of LTL, and prove that these logics arefirst-order expressively-complete. One of them is based on adding a "within"modality, evaluating a formula on a subword, to a logic CaRet previouslystudied in the context of verifying properties of recursive state machines(RSMs). The other logic, NWTL, is based on the notion of a summary path thatuses both the linear and nesting structures. For NWTL we show thatsatisfiability is EXPTIME-complete, and that model-checking can be done in timepolynomial in the size of the RSM model and exponential in the size of the NWTLformula (and is also EXPTIME-complete). Finally, we prove that first-orderlogic over nested words has the three-variable property, and we present atemporal logic for nested words which is complete for the two-variable fragmentof first-order.

Streaming Tree Transducers

  Theory of tree transducers provides a foundation for understandingexpressiveness and complexity of analysis problems for specification languagesfor transforming hierarchically structured data such as XML documents. Weintroduce streaming tree transducers as an analyzable, executable, andexpressive model for transforming unranked ordered trees in a single pass.Given a linear encoding of the input tree, the transducer makes a singleleft-to-right pass through the input, and computes the output in linear timeusing a finite-state control, a visibly pushdown stack, and a finite number ofvariables that store output chunks that can be combined using the operations ofstring-concatenation and tree-insertion. We prove that the expressiveness ofthe model coincides with transductions definable using monadic second-orderlogic (MSO). Existing models of tree transducers either cannot implement allMSO-definable transformations, or require regular look ahead that prohibitssingle-pass implementation. We show a variety of analysis problems such astype-checking and checking functional equivalence are solvable for our model.

Decision Problems for Additive Regular Functions

  Additive Cost Register Automata (ACRA) map strings to integers using a finiteset of registers that are updated using assignments of the form "x := y + c" atevery step. The corresponding class of additive regular functions has multipleequivalent characterizations, appealing closure properties, and a decidableequivalence problem. In this paper, we solve two decision problems for thismodel. First, we define the register complexity of an additive regular functionto be the minimum number of registers that an ACRA needs to compute it. Wecharacterize the register complexity by a necessary and sufficient conditionregarding the largest subset of registers whose values can be made far apartfrom one another. We then use this condition to design a PSPACE algorithm tocompute the register complexity of a given ACRA, and establish a matching lowerbound. Our results also lead to a machine-independent characterization of theregister complexity of additive regular functions. Second, we considertwo-player games over ACRAs, where the objective of one of the players is toreach a target set while minimizing the cost. We show the correspondingdecision problem to be EXPTIME-complete when costs are non-negative integers,but undecidable when costs are integers.

Counter-Strategy Guided Refinement of GR(1) Temporal Logic  Specifications

  The reactive synthesis problem is to find a finite-state controller thatsatisfies a given temporal-logic specification regardless of how itsenvironment behaves. Developing a formal specification is a challenging andtedious task and initial specifications are often unrealizable. In many cases,the source of unrealizability is the lack of adequate assumptions on theenvironment of the system. In this paper, we consider the problem ofautomatically correcting an unrealizable specification given in the generalizedreactivity (1) fragment of linear temporal logic by adding assumptions on theenvironment. When a temporal-logic specification is unrealizable, the synthesisalgorithm computes a counter-strategy as a witness. Our algorithm then analyzesthis counter-strategy and synthesizes a set of candidate environmentassumptions that can be used to remove the counter-strategy from theenvironment's possible behaviors. We demonstrate the applicability of ourapproach with several case studies.

Synthesizing Finite-state Protocols from Scenarios and Requirements

  Scenarios, or Message Sequence Charts, offer an intuitive way of describingthe desired behaviors of a distributed protocol. In this paper we propose a newway of specifying finite-state protocols using scenarios: we show that it ispossible to automatically derive a distributed implementation from a set ofscenarios augmented with a set of safety and liveness requirements, providedthe given scenarios adequately \emph{cover} all the states of the desiredimplementation. We first derive incomplete state machines from the givenscenarios, and then synthesis corresponds to completing the transition relationof individual processes so that the global product meets the specifiedrequirements. This completion problem, in general, has the same complexity,PSPACE, as the verification problem, but unlike the verification problem, isNP-complete for a constant number of processes. We present two algorithms forsolving the completion problem, one based on a heuristic search in the space ofpossible completions and one based on OBDD-based symbolic fixpoint computation.We evaluate the proposed methodology for protocol specification and theeffectiveness of the synthesis algorithms using the classical alternating-bitprotocol.

Results and Analysis of SyGuS-Comp'15

  Syntax-Guided Synthesis (SyGuS) is the computational problem of finding animplementation f that meets both a semantic constraint given by a logicalformula $\varphi$ in a background theory T, and a syntactic constraint given bya grammar G, which specifies the allowed set of candidate implementations. Sucha synthesis problem can be formally defined in SyGuS-IF, a language that isbuilt on top of SMT-LIB.  The Syntax-Guided Synthesis Competition (SyGuS-comp) is an effort tofacilitate, bring together and accelerate research and development of efficientsolvers for SyGuS by providing a platform for evaluating different synthesistechniques on a comprehensive set of benchmarks. In this year's competition weadded two specialized tracks: a track for conditional linear arithmetic, wherethe grammar need not be specified and is implicitly assumed to be that of theLIA logic of SMT-LIB, and a track for invariant synthesis problems, withspecial constructs conforming to the structure of an invariant synthesisproblem. This paper presents and analyzes the results of SyGuS-comp'15.

SyGuS-Comp 2016: Results and Analysis

  Syntax-Guided Synthesis (SyGuS) is the computational problem of finding animplementation f that meets both a semantic constraint given by a logicalformula $\varphi$ in a background theory T, and a syntactic constraint given bya grammar G, which specifies the allowed set of candidate implementations. Sucha synthesis problem can be formally defined in SyGuS-IF, a language that isbuilt on top of SMT-LIB.  The Syntax-Guided Synthesis Competition (SyGuS-Comp) is an effort tofacilitate, bring together and accelerate research and development of efficientsolvers for SyGuS by providing a platform for evaluating different synthesistechniques on a comprehensive set of benchmarks. In this year's competition weadded a new track devoted to programming by examples. This track consisted oftwo categories, one using the theory of bit-vectors and one using the theory ofstrings. This paper presents and analyses the results of SyGuS-Comp'16.

SyGuS-Comp 2017: Results and Analysis

  Syntax-Guided Synthesis (SyGuS) is the computational problem of finding animplementation f that meets both a semantic constraint given by a logicalformula phi in a background theory T, and a syntactic constraint given by agrammar G, which specifies the allowed set of candidate implementations. Such asynthesis problem can be formally defined in SyGuS-IF, a language that is builton top of SMT-LIB.  The Syntax-Guided Synthesis Competition (SyGuS-Comp) is an effort tofacilitate, bring together and accelerate research and development of efficientsolvers for SyGuS by providing a platform for evaluating different synthesistechniques on a comprehensive set of benchmarks. In this year's competition sixnew solvers competed on over 1500 benchmarks. This paper presents and analysesthe results of SyGuS-Comp'17.

Streamable Regular Transductions

  Motivated by real-time monitoring and data processing applications, wedevelop a formal theory of quantitative queries for streaming data that can beevaluated efficiently. We consider the model of unambiguous Cost RegisterAutomata (CRAs), which are machines that combine finite-state control (foridentifying regular patterns) with a finite set of data registers (forcomputing numerical aggregates). The definition of CRAs is parameterized by thecollection of numerical operations that can be applied to the registers. Thesemachines give rise to the class of streamable regular transductions (SR), andto the class of streamable linear regular transductions (SLR) when the registerupdates are copyless, i.e. every register appears at most once theright-hand-side expressions of the updates. We give a logical characterizationof the class SR (resp., SLR) using MSO-definable transformations from stringsto DAGs (resp., trees) without backward edges. Additionally, we establish thatthe two classes SR and SLR are closed under operations that are relevant fordesigning query languages. Finally, we study the relationship with weightedautomata (WA), and show that CRAs over a suitably chosen set of operationscorrespond to WA, thus establishing that WA are a special case of CRAs.

Equilibria in Quantitative Concurrent Games

  Synthesis of finite-state controllers from high-level specifications inmulti-agent systems can be reduced to solving multi-player concurrent gamesover finite graphs. The complexity of solving such games with qualitativeobjectives for agents, such as reaching a target set, is well understoodresulting in tools with applications in robotics. In this paper, we introducequantitative concurrent graph games, where transitions have separate costs fordifferent agents, and each agent attempts to reach its target set whileminimizing its own cost along the path. In this model, a solution to the gamecorresponds to a set of strategies, one per agent, that forms a Nashequilibrium. We study the problem of computing the set of all Pareto-optimalNash equilibria, and give a comprehensive analysis of its complexity andrelated problems such as the price of stability and the price of anarchy. Inparticular, while checking the existence of a Nash equilibrium is NP-completein general, with multiple parameters contributing to the computational hardnessseparately, two-player games with bounded costs on individual transitions admita polynomial-time solution.

Verisig: verifying safety properties of hybrid systems with neural  network controllers

  This paper presents Verisig, a hybrid system approach to verifying safetyproperties of closed-loop systems using neural networks as controllers.Although techniques exist for verifying input/output properties of the neuralnetwork itself, these methods cannot be used to verify properties of theclosed-loop system (since they work with piecewise-linear constraints that donot capture non-linear plant dynamics). To overcome this challenge, we focus onsigmoid-based networks and exploit the fact that the sigmoid is the solution toa quadratic differential equation, which allows us to transform the neuralnetwork into an equivalent hybrid system. By composing the network's hybridsystem with the plant's, we transform the problem into a hybrid systemverification problem which can be solved using state-of-the-art reachabilitytools. We show that reachability is decidable for networks with one hiddenlayer and decidable for general networks if Schanuel's conjecture is true. Weevaluate the applicability and scalability of Verisig in two case studies, onefrom reinforcement learning and one in which the neural network is used toapproximate a model predictive controller.

Algorithmic Verification of Single-Pass List Processing Programs

  We introduce streaming data string transducers that map input data strings tooutput data strings in a single left-to-right pass in linear time. Data stringsare (unbounded) sequences of data values, tagged with symbols from a finiteset, over a potentially infinite data domain that supports only the operationsof equality and ordering. The transducer uses a finite set of states, a finiteset of variables ranging over the data domain, and a finite set of variablesranging over data strings. At every step, it can make decisions based on thenext input symbol, updating its state, remembering the input data value in itsdata variables, and updating data-string variables by concatenating data-stringvariables and new symbols formed from data variables, while avoidingduplication. We establish that the problems of checking functional equivalenceof two streaming transducers, and of checking whether a streaming transducersatisfies pre/post verification conditions specified by streaming acceptorsover input/output data-strings, are in PSPACE. We identify a class ofimperative and a class of functional programs, manipulating lists of dataitems, which can be effectively translated to streaming data-stringtransducers. The imperative programs dynamically modify a singly-linked heap bychanging next-pointers of heap-nodes and by adding new nodes. The mainrestriction specifies how the next-pointers can be used for traversal. We alsoidentify an expressively equivalent fragment of functional programs thattraverse a list using syntactically restricted recursive calls. Our resultslead to algorithms for assertion checking and for checking functionalequivalence of two programs, written possibly in different programming styles,for commonly used routines such as insert, delete, and reverse.

Regular Functions, Cost Register Automata, and Generalized Min-Cost  Problems

  Motivated by the successful application of the theory of regular languages toformal verification of finite-state systems, there is a renewed interest indeveloping a theory of analyzable functions from strings to numerical valuesthat can provide a foundation for analyzing {\em quantitative} properties offinite-state systems. In this paper, we propose a deterministic model forassociating costs with strings that is parameterized by operations of interest(such as addition, scaling, and $\min$), a notion of {\em regularity} thatprovides a yardstick to measure expressiveness, and study decision problems andtheoretical properties of resulting classes of cost functions. Our definitionof regularity relies on the theory of string-to-tree transducers, and allowsassociating costs with events that are conditional upon regular properties offuture events. Our model of {\em cost register automata} allows computation ofregular functions using multiple "write-only" registers whose values can becombined using the allowed set of operations. We show that classicalshortest-path algorithms as well as algorithms designed for computing {\emdiscounted costs}, can be adopted for solving the min-cost problems for themore general classes of functions specified in our model. Cost registerautomata with $\min$ and increment give a deterministic model that isequivalent to {\em weighted automata}, an extensively studied nondeterministicmodel, and this connection results in new insights and new open problems.

Safe Schedulability of Bounded-Rate Multi-Mode Systems

  Bounded-rate multi-mode systems (BMMS) are hybrid systems that can switchfreely among a finite set of modes, and whose dynamics is specified by a finitenumber of real-valued variables with mode-dependent rates that can vary withingiven bounded sets. The schedulability problem for BMMS is defined as aninfinite-round game between two players---the scheduler and theenvironment---where in each round the scheduler proposes a time and a modewhile the environment chooses an allowable rate for that mode, and the state ofthe system changes linearly in the direction of the rate vector. The goal ofthe scheduler is to keep the state of the system within a pre-specified safeset using a non-Zeno schedule, while the goal of the environment is theopposite. Green scheduling under uncertainty is a paradigmatic example of BMMSwhere a winning strategy of the scheduler corresponds to a robustenergy-optimal policy. We present an algorithm to decide whether the schedulerhas a winning strategy from an arbitrary starting state, and give an algorithmto compute such a winning strategy, if it exists. We show that theschedulability problem for BMMS is co-NP complete in general, but for twovariables it is in PTIME. We also study the discrete schedulability problemwhere the environment has only finitely many choices of rate vectors in eachmode and the scheduler can make decisions only at multiples of a given clockperiod, and show it to be EXPTIME-complete.

Regular Combinators for String Transformations

  We focus on (partial) functions that map input strings to a monoid such asthe set of integers with addition and the set of output strings withconcatenation. The notion of regularity for such functions has been definedusing two-way finite-state transducers, (one-way) cost register automata, andMSO-definable graph transformations. In this paper, we give an algebraic andmachine-independent characterization of this class analogous to the definitionof regular languages by regular expressions. When the monoid is commutative, weprove that every regular function can be constructed from constant functionsusing the combinators of choice, split sum, and iterated sum, that are analogsof union, concatenation, and Kleene-*, respectively, but enforce unique (orunambiguous) parsing. Our main result is for the general case ofnon-commutative monoids, which is of particular interest for capturing regularstring-to-string transformations for document processing. We prove that thefollowing additional combinators suffice for constructing all regularfunctions: (1) the left-additive versions of split sum and iterated sum, whichallow transformations such as string reversal; (2) sum of functions, whichallows transformations such as copying of strings; and (3) functioncomposition, or alternatively, a new concept of chained sum, which allowsoutput values from adjacent blocks to mix.

Automatic Completion of Distributed Protocols with Symmetry

  A distributed protocol is typically modeled as a set of communicatingprocesses, where each process is described as an extended state machine alongwith fairness assumptions, and its correctness is specified using safety andliveness requirements. Designing correct distributed protocols is a challengingtask. Aimed at simplifying this task, we allow the designer to leave some ofthe guards and updates to state variables in the description of extended statemachines as unknown functions. The protocol completion problem then is to findinterpretations for these unknown functions while guaranteeing correctness. Inmany distributed protocols, process behaviors are naturally symmetric, andthus, synthesized expressions are further required to obey symmetryconstraints. Our counterexample-guided synthesis algorithm consists ofrepeatedly invoking two phases. In the first phase, candidates for unknownexpressions are generated using the SMT solver Z3. This phase requirescarefully orchestrating constraints to enforce the desired symmetry inread/write accesses. In the second phase, the resulting completed protocol ischecked for correctness using a custom-built model checker that handlesfairness assumptions, safety and liveness requirements, and exploits symmetry.When model checking fails, our tool examines a set of counterexamples tosafety/liveness properties to generate constraints on unknown functions thatmust be satisfied by subsequent completions. For evaluation, we show that ourprototype is able to automatically discover interesting missing details indistributed protocols for mutual exclusion, self stabilization, and cachecoherence.

Synthesis through Unification

  Given a specification and a set of candidate programs (program space), theprogram synthesis problem is to find a candidate program that satisfies thespecification. We present the synthesis through unification (STUN) approach,which is an extension of the counter-example guided inductive synthesis (CEGIS)approach. In CEGIS, the synthesizer maintains a subset S of inputs and acandidate program Prog that is correct for S. The synthesizer repeatedly checksif there exists a counter-example input c such that the execution of Prog isincorrect on c. If so, the synthesizer enlarges S to include c, and picks aprogram from the program space that is correct for the new set S.  The STUN approach extends CEGIS with the idea that given a program Prog thatis correct for a subset of inputs, the synthesizer can try to find a programProg' that is correct for the rest of the inputs. If Prog and Prog' can beunified into a program in the program space, then a solution has been found. Wepresent a generic synthesis procedure based on the STUN approach and specializeit for three different domains by providing the appropriate unificationoperators. We implemented these specializations in prototype tools, and we showthat our tools often per- forms significantly better on standard benchmarksthan a tool based on a pure CEGIS approach.

REAFFIRM: Model-Based Repair of Hybrid Systems for Improving Resiliency

  Model-based design offers a promising approach for assisting developers tobuild reliable and secure cyber-physical systems (CPSs) in a systematic manner.In this methodology, a designer first constructs a model, with mathematicallyprecise semantics, of the system under design, and performs extensive analysiswith respect to correctness requirements before generating the implementationfrom the model. However, as new vulnerabilities are discovered, requirementsevolve aimed at ensuring resiliency. There is currently a shortage of aninexpensive, automated mechanism that can effectively repair the initialdesign, and a model-based system developer regularly needs to redesign andreimplement the system from scratch. In this paper, we propose a newmethodology along with a Matlab toolkit called REAFFIRM to facilitate themodel-based repair for improving the resiliency of CPSs. REAFFIRM takes theinputs including 1) an original hybrid system modeled as a Simulink/Stateflowdiagram, 2) a given resiliency pattern specified as a model transformationscript, and 3) a safety requirement expressed as a Signal Temporal Logicformula, and then outputs a repaired model which satisfies the requirement. Theoverall structure of REAFFIRM contains two main modules, a modeltransformation, and a model synthesizer built on top of the falsification toolBreach. We introduce a new model transformation language for hybrid systems,which we call HATL to allow a designer to specify resiliency patterns. Toevaluate the proposed approach, we use REAFFIRM to automatically synthesizerepaired models for an adaptive cruise control (ACC) system under a GPS sensorspoofing attack, for a single-machine infinite-bus (SMIB) system under asliding-mode switching attack, and for a missile guidance system undergyroscopes sensor attack.

Systems Computing Challenges in the Internet of Things

  A recent McKinsey report estimates the economic impact of the Internet ofThings (IoT) to be between $3.9 to $11 trillion dollars by 20251 . IoT has thepotential to have a profound impact on our daily lives, including technologiesfor the home, for health, for transportation, and for managing our naturalresources. The Internet was largely driven by information and ideas generatedby people, but advances in sensing and hardware have enabled computers to moreeasily observe the physical world. Coupling this additional layer ofinformation with advances in machine learning brings dramatic new capabilitiesincluding the ability to capture and process tremendous amounts of data; topredict behaviors, activities, and the future in uncanny ways; and tomanipulate the physical world in response. This trend will fundamentally changehow people interact with physical objects and the environment. Success indeveloping value-added capabilities around IoT requires a broad approach thatincludes expertise in sensing and hardware, machine learning, networkedsystems, human-computer interaction, security, and privacy. Strategies formaking IoT practical and spurring its ultimate adoption also require amultifaceted approach that often transcends technology, such as with concernsover data security, privacy, public policy, and regulatory issues. In thispaper we argue that existing best practices in building robust and securesystems are insufficient to address the new challenges that IoT systems willpresent. We provide recommendations regarding investments in research areasthat will help address inadequacies in existing systems, practices, tools, andpolicies.

