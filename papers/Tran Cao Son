Planning with Preferences using Logic Programming

  We present a declarative language, PP, for the high-level specification ofpreferences between possible solutions (or trajectories) of a planning problem.This novel language allows users to elegantly express non-trivial,multi-dimensional preferences and priorities over such preferences. Thesemantics of PP allows the identification of most preferred trajectories for agiven goal. We also provide an answer set programming implementation ofplanning problems with PP preferences.

Reasoning and Planning with Sensing Actions, Incomplete Information, and  Static Causal Laws using Answer Set Programming

  We extend the 0-approximation of sensing actions and incomplete informationin [Son and Baral 2000] to action theories with static causal laws and proveits soundness with respect to the possible world semantics. We also show thatthe conditional planning problem with respect to this approximation isNP-complete. We then present an answer set programming based conditionalplanner, called ASCP, that is capable of generating both conformant plans andconditional plans in the presence of sensing actions, incomplete informationabout the initial state, and static causal laws. We prove the correctness ofour implementation and argue that our planner is sound and complete withrespect to the proposed approximation. Finally, we present experimental resultscomparing ASCP to other planners.

Domain-Dependent Knowledge in Answer Set Planning

  In this paper we consider three different kinds of domain-dependent controlknowledge (temporal, procedural and HTN-based) that are useful in planning. Ourapproach is declarative and relies on the language of logic programming withanswer set semantics (AnsProlog*). AnsProlog* is designed to plan withoutcontrol knowledge. We show how temporal, procedural and HTN-based controlknowledge can be incorporated into AnsProlog* by the modular addition of asmall number of domain-dependent rules, without the need to modify the planner.We formally prove the correctness of our planner, both in the absence andpresence of the control knowledge. Finally, we perform some initialexperimentation that demonstrates the potential reduction in planning time thatcan be achieved when procedural domain knowledge is used to solve planningproblems with large plan length.

A State-Based Regression Formulation for Domains with Sensing  Actions<br> and Incomplete Information

  We present a state-based regression function for planning domains where anagent does not have complete information and may have sensing actions. Weconsider binary domains and employ a three-valued characterization of domainswith sensing actions to define the regression function. We prove the soundnessand completeness of our regression formulation with respect to the definitionof progression. More specifically, we show that (i) a plan obtained throughregression for a planning problem is indeed a progression solution of thatplanning problem, and that (ii) for each plan found through progression, usingregression one obtains that plan or an equivalent one.

Justifications for Logic Programs under Answer Set Semantics

  The paper introduces the notion of off-line justification for Answer SetProgramming (ASP). Justifications provide a graph-based explanation of thetruth value of an atom w.r.t. a given answer set. The paper extends also thisnotion to provide justification of atoms during the computation of an answerset (on-line justification), and presents an integration of on-linejustifications within the computation model of Smodels. Off-line and on-linejustifications provide useful tools to enhance understanding of ASP, and theyoffer a basic data structure to support methodologies and tools for debugginganswer set programs. A preliminary implementation has been developed inASP-PROLOG.  (To appear in Theory and Practice of Logic Programming (TPLP))

Regression with respect to sensing actions and partial states

  In this paper, we present a state-based regression function for planningdomains where an agent does not have complete information and may have sensingactions. We consider binary domains and employ the 0-approximation [Son & Baral2001] to define the regression function. In binary domains, the use of0-approximation means using 3-valued states. Although planning using thisapproach is incomplete with respect to the full semantics, we adopt it to havea lower complexity. We prove the soundness and completeness of our regressionformulation with respect to the definition of progression. More specifically,we show that (i) a plan obtained through regression for a planning problem isindeed a progression solution of that planning problem, and that (ii) for eachplan found through progression, using regression one obtains that plan or anequivalent one. We then develop a conditional planner that utilizes ourregression function. We prove the soundness and completeness of our planningalgorithm and present experimental results with respect to several well knownplanning problems in the literature.

An Action Language for Multi-Agent Domains: Foundations

  In multi-agent domains (MADs), an agent's action may not just change theworld and the agent's knowledge and beliefs about the world, but also maychange other agents' knowledge and beliefs about the world and their knowledgeand beliefs about other agents' knowledge and beliefs about the world. Thegoals of an agent in a multi-agent world may involve manipulating the knowledgeand beliefs of other agents' and again, not just their knowledge/belief aboutthe world, but also their knowledge about other agents' knowledge about theworld. Our goal is to present an action language (mA+) that has the necessaryfeatures to address the above aspects in representing and RAC in MADs. mA+allows the representation of and reasoning about different types of actionsthat an agent can perform in a domain where many other agents might bepresent---such as world-altering actions, sensing actions, andannouncement/communication actions. It also allows the specification of agents'dynamic awareness of action occurrences which has future implications on whatagents' know about the world and other agents' knowledge about the world. mA+considers three different types of awareness: full,- partial- awareness, andcomplete oblivion of an action occurrence and its effects. This keeps thelanguage simple, yet powerful enough to address a large variety of knowledgemanipulation scenarios in MADs. The semantics of mA+ relies on the notion ofstate, which is described by a pointed Kripke model and is used to encode theagent's knowledge and the real state of the world. It is defined by atransition function that maps pairs of actions and states into sets of states.We illustrate properties of the action theories, including properties thatguarantee finiteness of the set of initial states and their practicalimplementability. Finally, we relate mA+ to other related formalisms thatcontribute to RAC in MADs.

A Constructive Semantic Characterization of Aggregates in ASP

  This technical note describes a monotone and continuous fixpoint operator tocompute the answer sets of programs with aggregates. The fixpoint operatorrelies on the notion of aggregate solution. Under certain conditions, thisoperator behaves identically to the three-valued immediate consequence operator$\Phi^{aggr}_P$ for aggregate programs, independently proposed Pelov et al.This operator allows us to closely tie the computational complexity of theanswer set checking and answer sets existence problems to the cost of checkinga solution of the aggregates in the program. Finally, we relate the semanticsdescribed by the operator to other proposals for logic programming withaggregates.  To appear in Theory and Practice of Logic Programming (TPLP).

An Unfolding-Based Semantics for Logic Programming with Aggregates

  The paper presents two equivalent definitions of answer sets for logicprograms with aggregates. These definitions build on the notion of unfolding ofaggregates, and they are aimed at creating methodologies to translate logicprograms with aggregates to normal logic programs or positive programs, whoseanswer set semantics can be used to defined the semantics of the originalprograms. The first definition provides an alternative view of the semanticsfor logic programming with aggregates described by Pelov et al.  The second definition is similar to the traditional answer set definition fornormal logic programs, in that, given a logic program with aggregates and aninterpretation, the unfolding process produces a positive program. The papershows how this definition can be extended to consider aggregates in the head ofthe rules.  The proposed views of logic programming with aggregates are simple andcoincide with the ultimate stable model semantics, and with other semanticcharacterizations for large classes of program (e.g., programs with monotoneaggregates and programs that are aggregate-stratified).  Moreover, it can be directly employed to support an implementation usingavailable answer set solvers. The paper describes a system, called ASP^A, thatis capable of computing answer sets of programs with arbitrary (e.g.,recursively defined) aggregates.

Logic Programming for Finding Models in the Logics of Knowledge and its  Applications: A Case Study

  The logics of knowledge are modal logics that have been shown to be effectivein representing and reasoning about knowledge in multi-agent domains.Relatively few computational frameworks for dealing with computation of modelsand useful transformations in logics of knowledge (e.g., to support multi-agentplanning with knowledge actions and degrees of visibility) have been proposed.This paper explores the use of logic programming (LP) to encode interestingforms of logics of knowledge and compute Kripke models. The LP modeling isexpanded with useful operators on Kripke structures, to support multi-agentplanning in the presence of both world-altering and knowledge actions. Thisresults in the first ever implementation of a planner for this type of complexmulti-agent domains.

Revisiting Epistemic Specifications

  In 1991, Michael Gelfond introduced the language of epistemic specifications.The goal was to develop tools for modeling problems that require some form ofmeta-reasoning, that is, reasoning over multiple possible worlds. Despite theirrelevance to knowledge representation, epistemic specifications have receivedrelatively little attention so far. In this paper, we revisit the formalism ofepistemic specification. We offer a new definition of the formalism, proposeseveral semantics (one of which, under syntactic restrictions we assume, turnsout to be equivalent to the original semantics by Gelfond), derive somecomplexity results and, finally, show the effectiveness of the formalism formodeling problems requiring meta-reasoning considered recently by Faber andWoltran. All these results show that epistemic specifications deserve much moreattention that has been afforded to them so far.

Query Answering in Object Oriented Knowledge Bases in Logic Programming:  Description and Challenge for ASP

  Research on developing efficient and scalable ASP solvers can substantiallybenefit by the availability of data sets to experiment with. KB_Bio_101contains knowledge from a biology textbook, has been developed as part ofProject Halo, and has recently become available for research use. KB_Bio_101 isone of the largest KBs available in ASP and the reasoning with it isundecidable in general. We give a description of this KB and ASP programs for asuite of queries that have been of practical interest. We explain why thesequeries pose significant practical challenges for the current ASP solvers.

Logic and Constraint Logic Programming for Distributed Constraint  Optimization

  The field of Distributed Constraint Optimization Problems (DCOPs) has gainedmomentum, thanks to its suitability in capturing complex problems (e.g.,multi-agent coordination and resource allocation problems) that are naturallydistributed and cannot be realistically addressed in a centralized manner. Thestate of the art in solving DCOPs relies on the use of ad-hoc infrastructuresand ad-hoc constraint solving procedures. This paper investigates aninfrastructure for solving DCOPs that is completely built on logic programmingtechnologies. In particular, the paper explores the use of a general constraintsolver (a constraint logic programming system in this context) to handle theagent-level constraint solving. The preliminary experiments show that logicprogramming provides benefits over a state-of-the-art DCOP system, in terms ofperformance and scalability, opening the doors to the use of more advancedtechnology (e.g., search strategies and complex constraints) for solving DCOPs.

A Parallel Memory-efficient Epistemic Logic Program Solver: Harder,  Better, Faster

  As the practical use of answer set programming (ASP) has grown with thedevelopment of efficient solvers, we expect a growing interest in extensions ofASP as their semantics stabilize and solvers supporting them mature. EpistemicSpecifications, which adds modal operators K and M to the language of ASP, isone such extension. We call a program in this language an epistemic logicprogram (ELP). Solvers have thus far been practical for only the simplest ELPsdue to exponential growth of the search space. We describe a solver that isable to solve harder problems better (e.g., without exponentially-growingmemory needs w.r.t. K and M occurrences) and faster than any other known ELPsolver.

Solving Distributed Constraint Optimization Problems Using Logic  Programming

  This paper explores the use of Answer Set Programming (ASP) in solvingDistributed Constraint Optimization Problems (DCOPs). The paper provides thefollowing novel contributions: (1) It shows how one can formulate DCOPs aslogic programs; (2) It introduces ASP-DPOP, the first DCOP algorithm that isbased on logic programming; (3) It experimentally shows that ASP-DPOP can be upto two orders of magnitude faster than DPOP (its imperative programmingcounterpart) as well as solve some problems that DPOP fails to solve, due tomemory limitations; and (4) It demonstrates the applicability of ASP in a widearray of multi-agent problems currently modeled as DCOPs. Under considerationin Theory and Practice of Logic Programming (TPLP).

Experimenting with robotic intra-logistics domains

  We introduce the asprilo [1] framework to facilitate experimental studies ofapproaches addressing complex dynamic applications. For this purpose, we havechosen the domain of robotic intra-logistics. This domain is not only highlyrelevant in the context of today's fourth industrial revolution but it moreovercombines a multitude of challenging issues within a single uniform framework.This includes multi-agent planning, reasoning about action, change, resources,strategies, etc. In return, asprilo allows users to study alternative solutionsas regards effectiveness and scalability. Although asprilo relies on Answer SetProgramming and Python, it is readily usable by any system complying with itsfact-oriented interface format. This makes it attractive for benchmarking andteaching well beyond logic programming. More precisely, asprilo consists of aversatile benchmark generator, solution checker and visualizer as well as abunch of reference encodings featuring various ASP techniques. Importantly, thevisualizer's animation capabilities are indispensable for complex scenarioslike intra-logistics in order to inspect valid as well as invalid solutioncandidates. Also, it allows for graphically editing benchmark layouts that canbe used as a basis for generating benchmark suites.  [1] asprilo stands for Answer Set Programming for robotic intra-logistics

Phylotastic: An Experiment in Creating, Manipulating, and Evolving  Phylogenetic Biology Workflows Using Logic Programming

  Evolutionary Biologists have long struggled with the challenge of developinganalysis workflows in a flexible manner, thus facilitating the reuse ofphylogenetic knowledge. An evolutionary biology workflow can be viewed as aplan which composes web services that can retrieve, manipulate, and producephylogenetic trees. The Phylotastic project was launched two years ago as acollaboration between evolutionary biologists and computer scientists, with thegoal of developing an open architecture to facilitate the creation of suchanalysis workflows. While composition of web services is a problem that hasbeen extensively explored in the literature, including within the logicprogramming domain, the incarnation of the problem in Phylotastic provides anumber of additional challenges. Along with the need to integrate preferencesand formal ontologies in the description of the desired workflow, evolutionarybiologists tend to construct workflows in an incremental manner, bysuccessively refining the workflow, by indicating desired changes (e.g.,exclusion of certain services, modifications of the desired output). This leadsto the need of successive iterations of incremental replanning, to develop anew workflow that integrates the requested changes while minimizing the changesto the original workflow. This paper illustrates how Phylotastic has addressedthe challenges of creating and refining phylogenetic analysis workflows usinglogic programming technology and how such solutions have been used within thegeneral framework of the Phylotastic project. Under consideration in Theory andPractice of Logic Programming (TPLP).

