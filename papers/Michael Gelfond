Revisiting Epistemic Specifications

  In 1991, Michael Gelfond introduced the language of epistemic specifications.
The goal was to develop tools for modeling problems that require some form of
meta-reasoning, that is, reasoning over multiple possible worlds. Despite their
relevance to knowledge representation, epistemic specifications have received
relatively little attention so far. In this paper, we revisit the formalism of
epistemic specification. We offer a new definition of the formalism, propose
several semantics (one of which, under syntactic restrictions we assume, turns
out to be equivalent to the original semantics by Gelfond), derive some
complexity results and, finally, show the effectiveness of the formalism for
modeling problems requiring meta-reasoning considered recently by Faber and
Woltran. All these results show that epistemic specifications deserve much more
attention that has been afforded to them so far.


Vicious Circle Principle and Logic Programs with Aggregates

  The paper presents a knowledge representation language $\mathcal{A}log$ which
extends ASP with aggregates. The goal is to have a language based on simple
syntax and clear intuitive and mathematical semantics. We give some properties
of $\mathcal{A}log$, an algorithm for computing its answer sets, and comparison
with other approaches.


Vicious Circle Principle and Logic Programs with Aggregates

  The paper presents a knowledge representation language $\mathcal{A}log$ which
extends ASP with aggregates. The goal is to have a language based on simple
syntax and clear intuitive and mathematical semantics. We give some properties
of $\mathcal{A}log$, an algorithm for computing its answer sets, and comparison
with other approaches.


Language ASP{f} with Arithmetic Expressions and Consistency-Restoring
  Rules

  In this paper we continue the work on our extension of Answer Set Programming
by non-Herbrand functions and add to the language support for arithmetic
expressions and various inequality relations over non-Herbrand functions, as
well as consistency-restoring rules from CR-Prolog. We demonstrate the use of
this latest version of the language in the representation of important kinds of
knowledge.


Diagnostic reasoning with A-Prolog

  In this paper we suggest an architecture for a software agent which operates
a physical device and is capable of making observations and of testing and
repairing the device's components. We present simplified definitions of the
notions of symptom, candidate diagnosis, and diagnosis which are based on the
theory of action language ${\cal AL}$. The definitions allow one to give a
simple account of the agent's behavior in which many of the agent's tasks are
reduced to computing stable models of logic programs.


Probabilistic reasoning with answer sets

  This paper develops a declarative language, P-log, that combines logical and
probabilistic arguments in its reasoning. Answer Set Prolog is used as the
logical foundation, while causal Bayes nets serve as a probabilistic
foundation. We give several non-trivial examples and illustrate the use of
P-log for knowledge representation and updating of knowledge. We argue that our
approach to updates is more appealing than existing approaches. We give
sufficiency conditions for the coherency of P-log programs and show that Bayes
nets can be easily mapped to coherent P-log programs.


Modular Action Language ALM

  The paper introduces a new modular action language, ALM, and illustrates the
methodology of its use. It is based on the approach of Gelfond and Lifschitz
(1993; 1998) in which a high-level action language is used as a front end for a
logic programming system description. The resulting logic programming
representation is used to perform various computational tasks. The methodology
based on existing action languages works well for small and even medium size
systems, but is not meant to deal with larger systems that require structuring
of knowledge. ALM is meant to remedy this problem. Structuring of knowledge in
ALM is supported by the concepts of module (a formal description of a specific
piece of knowledge packaged as a unit), module hierarchy, and library, and by
the division of a system description of ALM into two parts: theory and
structure. A theory consists of one or more modules with a common theme,
possibly organized into a module hierarchy based on a dependency relation. It
contains declarations of sorts, attributes, and properties of the domain
together with axioms describing them. Structures are used to describe the
domain's objects. These features, together with the means for defining classes
of a domain as special cases of previously defined ones, facilitate the
stepwise development, testing, and readability of a knowledge base, as well as
the creation of knowledge representation libraries. To appear in Theory and
Practice of Logic Programming (TPLP).


SPARC - Sorted ASP with Consistency Restoring Rules

  This is a preliminary report on the work aimed at making CR-Prolog -- a
version of ASP with consistency restoring rules -- more suitable for use in
teaching and large applications. First we describe a sorted version of
CR-Prolog called SPARC. Second, we translate a basic version of the CR-Prolog
into the language of DLV and compare the performance with the state of the art
CR-Prolog solver. The results form the foundation for future more efficient and
user friendly implementation of SPARC and shed some light on the relationship
between two useful knowledge representation constructs: consistency restoring
rules and weak constraints of DLV.


KR$^3$: An Architecture for Knowledge Representation and Reasoning in
  Robotics

  This paper describes an architecture that combines the complementary
strengths of declarative programming and probabilistic graphical models to
enable robots to represent, reason with, and learn from, qualitative and
quantitative descriptions of uncertainty and knowledge. An action language is
used for the low-level (LL) and high-level (HL) system descriptions in the
architecture, and the definition of recorded histories in the HL is expanded to
allow prioritized defaults. For any given goal, tentative plans created in the
HL using default knowledge and commonsense reasoning are implemented in the LL
using probabilistic algorithms, with the corresponding observations used to
update the HL history. Tight coupling between the two levels enables automatic
selection of relevant variables and generation of suitable action policies in
the LL for each HL action, and supports reasoning with violation of defaults,
noisy observations and unreliable actions in large and complex domains. The
architecture is evaluated in simulation and on physical robots transporting
objects in indoor domains; the benefit on robots is a reduction in task
execution time of 39% compared with a purely probabilistic, but still
hierarchical, approach.


Causal Graph Justifications of Logic Programs

  In this work we propose a multi-valued extension of logic programs under the
stable models semantics where each true atom in a model is associated with a
set of justifications. These justifications are expressed in terms of causal
graphs formed by rule labels and edges that represent their application
ordering. For positive programs, we show that the causal justifications
obtained for a given atom have a direct correspon- dence to (relevant)
syntactic proofs of that atom using the program rules involved in the graphs.
The most interesting contribution is that this causal information is obtained
in a purely semantic way, by algebraic op- erations (product, sum and
application) on a lattice of causal values whose ordering relation expresses
when a justification is stronger than another. Finally, for programs with
negation, we define the concept of causal stable model by introducing an
analogous transformation to Gelfond and Lifschitz's program reduct. As a
result, default negation behaves as "absence of proof" and no justification is
derived from negative liter


An Algebra of Causal Chains

  In this work we propose a multi-valued extension of logic programs under the
stable models semantics where each true atom in a model is associated with a
set of justifications, in a similar spirit than a set of proof trees. The main
contribution of this paper is that we capture justifications into an algebra of
truth values with three internal operations: an addition '+' representing
alternative justifications for a formula, a commutative product '*'
representing joint interaction of causes and a non-commutative product '.'
acting as a concatenation or proof constructor. Using this multi-valued
semantics, we obtain a one-to-one correspondence between the syntactic proof
tree of a standard (non-causal) logic program and the interpretation of each
true atom in a model. Furthermore, thanks to this algebraic characterization we
can detect semantic properties like redundancy and relevance of the obtained
justifications. We also identify a lattice-based characterization of this
algebra, defining a direct consequences operator, proving its continuity and
that its least fix point can be computed after a finite number of iterations.
Finally, we define the concept of causal stable model by introducing an
analogous transformation to Gelfond and Lifschitz's program reduct.


Vicious Circle Principle and Formation of Sets in ASP Based Languages

  The paper continues the investigation of Poincare and Russel's Vicious Circle
Principle (VCP) in the context of the design of logic programming languages
with sets. We expand previously introduced language Alog with aggregates by
allowing infinite sets and several additional set related constructs useful for
knowledge representation and teaching. In addition, we propose an alternative
formalization of the original VCP and incorporate it into the semantics of new
language, Slog+, which allows more liberal construction of sets and their use
in programming rules. We show that, for programs without disjunction and
infinite sets, the formal semantics of aggregates in Slog+ coincides with that
of several other known languages. Their intuitive and formal semantics,
however, are based on quite different ideas and seem to be more involved than
that of Slog+.


REBA: A Refinement-Based Architecture for Knowledge Representation and
  Reasoning in Robotics

  This paper describes an architecture for robots that combines the
complementary strengths of probabilistic graphical models and declarative
programming to represent and reason with logic-based and probabilistic
descriptions of uncertainty and domain knowledge. An action language is
extended to support non-boolean fluents and non-deterministic causal laws. This
action language is used to describe tightly-coupled transition diagrams at two
levels of granularity, with a fine-resolution transition diagram defined as a
refinement of a coarse-resolution transition diagram of the domain. The
coarse-resolution system description, and a history that includes (prioritized)
defaults, are translated into an Answer Set Prolog (ASP) program. For any given
goal, inference in the ASP program provides a plan of abstract actions. To
implement each such abstract action, the robot automatically zooms to the part
of the fine-resolution transition diagram relevant to this action. A
probabilistic representation of the uncertainty in sensing and actuation is
then included in this zoomed fine-resolution system description, and used to
construct a partially observable Markov decision process (POMDP). The policy
obtained by solving the POMDP is invoked repeatedly to implement the abstract
action as a sequence of concrete actions, with the corresponding observations
being recorded in the coarse-resolution history and used for subsequent
reasoning. The architecture is evaluated in simulation and on a mobile robot
moving objects in an indoor domain, to show that it supports reasoning with
violation of defaults, noisy observations and unreliable actions, in complex
domains.


