Paraconsistency and Word Puzzles

  Word puzzles and the problem of their representations in logic languages have
received considerable attention in the last decade (Ponnuru et al. 2004;
Shapiro 2011; Baral and Dzifcak 2012; Schwitter 2013). Of special interest is
the problem of generating such representations directly from natural language
(NL) or controlled natural language (CNL). An interesting variation of this
problem, and to the best of our knowledge, scarcely explored variation in this
context, is when the input information is inconsistent. In such situations, the
existing encodings of word puzzles produce inconsistent representations and
break down. In this paper, we bring the well-known type of paraconsistent
logics, called Annotated Predicate Calculus (APC) (Kifer and Lozinskii 1992),
to bear on the problem. We introduce a new kind of non-monotonic semantics for
APC, called consistency preferred stable models and argue that it makes APC
into a suitable platform for dealing with inconsistency in word puzzles and,
more generally, in NL sentences. We also devise a number of general principles
to help the user choose among the different representations of NL sentences,
which might seem equivalent but, in fact, behave differently when inconsistent
information is taken into account. These principles can be incorporated into
existing CNL translators, such as Attempto Controlled English (ACE) (Fuchs et
al. 2008) and PENG Light (White and Schwitter 2009). Finally, we show that APC
with the consistency preferred stable model semantics can be equivalently
embedded in ASP with preferences over stable models, and we use this embedding
to implement this version of APC in Clingo (Gebser et al. 2011) and its Asprin
add-on (Brewka et al. 2015).


Differentially Private Hierarchical Count-of-Counts Histograms

  We consider the problem of privately releasing a class of queries that we
call hierarchical count-of-counts histograms. Count-of-counts histograms
partition the rows of an input table into groups (e.g., group of people in the
same household), and for every integer j report the number of groups of size j.
Hierarchical count-of-counts queries report count-of-counts histograms at
different granularities as per hierarchy defined on an attribute in the input
data (e.g., geographical location of a household at the national, state and
county levels). In this paper, we introduce this problem, along with
appropriate error metrics and propose a differentially private solution that
generates count-of-counts histograms that are consistent across all levels of
the hierarchy.


Taming the Infinite Chase: Query Answering under Expressive Integrity
  Constraints

  The chase algorithm is a fundamental tool for query evaluation and query
containment under constraints, where the constraints are (sub-classes of)
tuple-generating dependencies (TGDs) and equality generating depencies (EGDs).
So far, most of the research on this topic has focused on cases where the chase
procedure terminates, with some notable exceptions. In this paper we take a
general approach, and we propose large classes of TGDs under which the chase
does not always terminate. Our languages, in particular, are inspired by
guarded logic: we show that by enforcing syntactic properties on the form of
the TGDs, we are able to ensure decidability of the problem of answering
conjunctive queries despite the non-terminating chase. We provide tight
complexity bounds for the problem of conjunctive query evaluation for several
classes of TGDs. We then introduce EGDs, and provide a condition under which
EGDs do not interact with TGDs, and therefore do not take part in query
answering. We show applications of our classes of constraints to the problem of
answering conjunctive queries under F-Logic Lite, a recently introduced
ontology language, and under prominent tractable Description Logics languages.
All the results in this paper immediately extend to the problem of conjunctive
query containment.


Understanding Rulelog Computations in Silk

  Rulelog is a knowledge representation and reasoning language based on logic
programming under the well-founded semantics. It is an extension of the
language of Flora-2 and so supports inheritance and other object-oriented
features, as well as the higher-order syntax of Hilog. However, Rulelog rules
may also contain quantifiers and may be contra-positional. In addition, these
rules are evaluated in the presence of defeasibility mechanisms that include
rule cancellation, rule priorities, and other aspects. Rulelog programs are
sometimes developed by loosely coordinated teams of knowledge engineers (KEs)
who are not necessarily programmers. This requires not only declarative
debugging support, but also support for profiling to help KEs understand the
overall structure of a computation, including its termination properties. The
design of debugging and profiling tools is made more challenging because
Rulelog programs undergo a series of transformations into normal programs, so
that there is a cognitive distance between how rules are specified and how they
are executed.
  In this paper, we describe the debugging and profiling environment for
Rulelog implemented in the integrated development environment of the Silk
system. Our approach includes an interface to justification graphs, which treat
why-not and defeasibility as well as provenance of the rules supporting
answers. It also includes tools for trace-based analysis of computations to
permit understanding of erroneous non-termination and of general performance
issues. For semantically correct cases of the non-terminating behavior, Silk
offers a different approach, which addresses the problem in a formally sound
manner by leveraging a form of bounded rationality called restraint.


