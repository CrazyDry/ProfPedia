Knuthian Drawings of Series-Parallel Flowcharts

  Inspired by a classic paper by Knuth, we revisit the problem of drawingflowcharts of loop-free algorithms, that is, degree-three series-paralleldigraphs. Our drawing algorithms show that it is possible to produce Knuthiandrawings of degree-three series-parallel digraphs with good aspect ratios andsmall numbers of edge bends.

On the Algorithmic Complexity of the Mastermind Game with Black-Peg  Results

  In this paper, we study the algorithmic complexity of the Mastermind game,where results are single-color black pegs. This differs from the usualdual-color version of the game, but better corresponds to applications ingenetics. We show that it is NP-complete to determine if a sequence ofsingle-color Mastermind results have a satisfying vector. We also show how todevise efficient algorithms for discovering a hidden vector throughsingle-color queries. Indeed, our algorithm improves a previous method ofChvatal by almost a factor of 2.

Discrepancy-Sensitive Dynamic Fractional Cascading, Dominated Maxima  Searching, and 2-d Nearest Neighbors in Any Minkowski Metric

  This paper studies a discrepancy-sensitive approach to dynamic fractionalcascading. We provide an efficient data structure for dominated maximasearching in a dynamic set of points in the plane, which in turn leads to anefficient dynamic data structure that can answer queries for nearest neighborsusing any Minkowski metric. We provide an efficient data structure fordominated maxima searching in a dynamic set of points in the plane, which inturn leads to an efficient dynamic data structure that can answer queries fornearest neighbors using any Minkowski metric.

Data-Oblivious Graph Drawing Model and Algorithms

  We study graph drawing in a cloud-computing context where data is storedexternally and processed using a small local working storage. We show that anumber of classic graph drawing algorithms can be efficiently implemented insuch a framework where the client can maintain privacy while constructing adrawing of her graph.

Delta-confluent Drawings

  We generalize the tree-confluent graphs to a broader class of graphs calledDelta-confluent graphs. This class of graphs and distance-hereditary graphs, awell-known class of graphs, coincide. Some results about the visualization ofDelta-confluent graphs are also given.

Geometric Fingerprint Recognition via Oriented Point-Set Pattern  Matching

  Motivated by the problem of fingerprint matching, we present geometricapproximation algorithms for matching a pattern point set against a backgroundpoint set, where the points have angular orientations in addition to theirpositions.

The Melbourne Shuffle: Improving Oblivious Storage in the Cloud

  We present a simple, efficient, and secure data-oblivious randomized shufflealgorithm. This is the first secure data-oblivious shuffle that is not based onsorting. Our method can be used to improve previous oblivious storage solutionsfor network-based outsourcing of data.

Balanced Circle Packings for Planar Graphs

  We study balanced circle packings and circle-contact representations forplanar graphs, where the ratio of the largest circle's diameter to the smallestcircle's diameter is polynomial in the number of circles. We provide a numberof positive and negative results for the existence of such balancedconfigurations.

Invertible Bloom Lookup Tables

  We present a version of the Bloom filter data structure that supports notonly the insertion, deletion, and lookup of key-value pairs, but also allows acomplete listing of its contents with high probability, as long the number ofkey-value pairs is below a designed threshold. Our structure allows the numberof key-value pairs to greatly exceed this threshold during normal operation.Exceeding the threshold simply temporarily prevents content listing and reducesthe probability of a successful lookup. If later entries are deleted to returnthe structure below the threshold, everything again functions appropriately. Wealso show that simple variations of our structure are robust to certainstandard errors, such as the deletion of a key without a correspondinginsertion or the insertion of two distinct values for a key. The properties ofour structure make it suitable for several applications, including database andnetworking applications that we highlight.

Privacy-Preserving Access of Outsourced Data via Oblivious RAM  Simulation

  Suppose a client, Alice, has outsourced her data to an external storageprovider, Bob, because he has capacity for her massive data set, of size n,whereas her private storage is much smaller--say, of size O(n^{1/r}), for someconstant r > 1. Alice trusts Bob to maintain her data, but she would like tokeep its contents private. She can encrypt her data, of course, but she alsowishes to keep her access patterns hidden from Bob as well. We describe schemesfor the oblivious RAM simulation problem with a small logarithmic orpolylogarithmic amortized increase in access times, with a very highprobability of success, while keeping the external storage to be of size O(n).To achieve this, our algorithmic contributions include a parallel MapReducecuckoo-hashing algorithm and an external-memory dataoblivious sortingalgorithm.

The Rainbow Skip Graph: A Fault-Tolerant Constant-Degree P2P Relay  Structure

  We present a distributed data structure, which we call the rainbow skipgraph. To our knowledge, this is the first peer-to-peer data structure thatsimultaneously achieves high fault tolerance, constant-sized nodes, and fastupdate and query times for ordered data. It is a non-trivial adaptation of theSkipNet/skip-graph structures of Harvey et al. and Aspnes and Shah, so as toprovide fault-tolerance as these structures do, but to do so usingconstant-sized nodes, as in the family tree structure of Zatloukal and Harvey.It supports successor queries on a set of n items using O(log n) messages withhigh probability, an improvement over the expected O(log n) messages of thefamily tree.

Anonymous Card Shuffling and its Applications to Parallel Mixnets

  We study the question of how to shuffle $n$ cards when faced with an opponentwho knows the initial position of all the cards {\em and} can track every cardwhen permuted, {\em except} when one takes $K< n$ cards at a time and shufflesthem in a private buffer "behind your back," which we call {\em buffershuffling}. The problem arises naturally in the context of parallel mixnetservers as well as other security applications. Our analysis is based onrelated analyses of load-balancing processes. We include extensions tovariations that involve corrupted servers and adversarially injected messages,which correspond to an opponent who can peek at some shuffles in the buffer andwho can mark some number of the cards. In addition, our analysis makes noveluse of a sum-of-squares metric for anonymity, which leads to improvedperformance bounds for parallel mixnets and can also be used to boundwell-known existing anonymity measures.

Going Off-road: Transversal Complexity in Road Networks

  A geometric graph is a graph embedded in the plane with vertices at pointsand edges drawn as curves (which are usually straight line segments) betweenthose points. The average transversal complexity of a geometric graph is thenumber of edges of that graph that are crossed by random line or line segment.In this paper, we study the average transversal complexity of road networks. Byviewing road networks as multiscale-dispersed graphs, we show that a randomline will cross the edges of such a graph O(sqrt(n)) times on average. Inaddition, we provide by empirical evidence from experiments on the roadnetworks of the fifty states of United States and the District of Columbia thatthis bound holds in practice and has a small constant factor. Combining thisresult with data structuring techniques from computational geometry, allows usto show that we can then do point location and ray-shooting navigationalqueries with respect to road networks in O(sqrt(n) log n) expected time.Finally, we provide empirical justification for this claim as well.

BIOS ORAM: Improved Privacy-Preserving Data Access for Parameterized  Outsourced Storage

  Algorithms for oblivious random access machine (ORAM) simulation allow aclient, Alice, to obfuscate a pattern of data accesses with a server, Bob, whois maintaining Alice's outsourced data while trying to learn information abouther data. We present a novel ORAM scheme that improves the asymptotic I/Ooverhead of previous schemes for a wide range of size parameters forclient-side private memory and message blocks, from logarithmic to polynomial.Our method achieves statistical security for hiding Alice's access pattern and,with high probability, achieves an I/O overhead that ranges from $O(1)$ to$O(\log^2 n/(\log\log n)^2)$, depending on these size parameters, where $n$ isthe size of Alice's outsourced memory. Our scheme, which we call BIOS ORAM,combines multiple uses of B-trees with a reduction of ORAM simulation toisogrammic access sequences.

An Efficient Dynamic and Distributed RSA Accumulator

  We show how to use the RSA one-way accumulator to realize an efficient anddynamic authenticated dictionary, where untrusted directories providecryptographically verifiable answers to membership queries on a set maintainedby a trusted source. Our accumulator-based scheme for authenticateddictionaries supports efficient incremental updates of the underlying set byinsertions and deletions of elements. Also, the user can optimally verify inconstant time the authenticity of the answer provided by a directory with asimple and practical algorithm. We have also implemented this scheme and wegive empirical results that can be used to determine the best strategy forsystems implementation with respect to resources that are available. This workhas applications to certificate revocation in public key infrastructure andend-to-end integrity of data collections published by third parties on theInternet.

Data-Oblivious External-Memory Algorithms for the Compaction, Selection,  and Sorting of Outsourced Data

  We present data-oblivious algorithms in the external-memory model forcompaction, selection, and sorting. Motivation for such problems comes fromclients who use outsourced data storage services and wish to mask their dataaccess patterns. We show that compaction and selection can be donedata-obliviously using $O(N/B)$ I/Os, and sorting can be done, with a highprobability of success, using $O((N/B)\log_{M/B} (N/B))$ I/Os. Our methods usea number of new algorithmic techniques, including data-oblivious uses ofinvertible Bloom lookup tables, a butterfly-like compression network,randomized data thinning, and "shuffle-and-deal" data perturbation. Inaddition, since data-oblivious sorting is the bottleneck in the "inner loop" inexisting oblivious RAM simulations, our sorting result improves the amortizedtime overhead to do oblivious RAM simulation by a logarithmic factor in theexternal-memory model.

Simulating Parallel Algorithms in the MapReduce Framework with  Applications to Parallel Computational Geometry

  In this paper, we describe efficient MapReduce simulations of parallelalgorithms specified in the BSP and PRAM models. We also provide someapplications of these simulation results to problems in parallel computationalgeometry for the MapReduce framework, which result in efficient MapReducealgorithms for sorting, 1-dimensional all nearest-neighbors, 2-dimensionalconvex hulls, 3-dimensional convex hulls, and fixed-dimensional linearprogramming. For the case when reducers can have a buffer size of$B=O(n^\epsilon)$, for a small constant $\epsilon>0$, all of our MapReducealgorithms for these applications run in a constant number of rounds and have alinear-sized message complexity, with high probability, while guaranteeing withhigh probability that all reducer lists are of size $O(B)$.

Randomized Shellsort: A Simple Oblivious Sorting Algorithm

  In this paper, we describe randomized Shellsort--a simple, randomized,data-oblivious version of the Shellsort algorithm that always runs in O(n logn) time and, as we show, succeeds in sorting any given input permutation withvery high probability. Thus, randomized Shellsort is simultaneously simple,time-optimal, and data-oblivious. Taken together, these properties implyapplications in the design of new efficient privacy-preserving computationsbased on the secure multi-party computation (SMC) paradigm. In addition, by atrivial conversion of this Monte Carlo algorithm to its Las Vegas equivalent,one gets the first version of Shellsort with a running time that is provablyO(n log n) with very high probability.

Cloning Voronoi Diagrams via Retroactive Data Structures

  We address the problem of replicating a Voronoi diagram $V(S)$ of a planarpoint set $S$ by making proximity queries, which are of three possible (indecreasing order of information content): 1. the exact location of the nearestsite(s) in $S$; 2. the distance to and label(s) of the nearest site(s) in $S$;3. a unique label for every nearest site in $S$. We provide algorithms showinghow queries of Type 1 and Type 2 allow an exact cloning of $V(S)$ with $O(n)$queries and $O(n \log^2 n)$ processing time. We also prove that queries of Type3 can never exactly clone $V(S)$, but we show that with $O(n\log\frac{1}{\epsilon})$ queries we can construct an $\epsilon$-approximatecloning of $V(S)$. In addition to showing the limits of nearest-neighbordatabase security, our methods also provide one of the first naturalalgorithmic applications of retroactive data structures.

Spin-the-bottle Sort and Annealing Sort: Oblivious Sorting via  Round-robin Random Comparisons

  We study sorting algorithms based on randomized round-robin comparisons.Specifically, we study Spin-the-bottle sort, where comparisons areunrestricted, and Annealing sort, where comparisons are restricted to adistance bounded by a \emph{temperature} parameter. Both algorithms are simple,randomized, data-oblivious sorting algorithms, which are useful inprivacy-preserving computations, but, as we show, Annealing sort is much moreefficient. We show that there is an input permutation that causesSpin-the-bottle sort to require $\Omega(n^2\log n)$ expected time in order tosucceed, and that in $O(n^2\log n)$ time this algorithm succeeds with highprobability for any input. We also show there is an implementation of Annealingsort that runs in $O(n\log n)$ time and succeeds with very high probability.

Windows into Geometric Events: Data Structures for Time-Windowed  Querying of Temporal Point Sets

  We study geometric data structures for sets of point-based temporal events,answering time-windowed queries, i.e., given a contiguous time interval weanswer common geometric queries about the point events with time stamps in thisinterval. The geometric queries we consider include queries based on theskyline, convex hull, and proximity relations of the point set. We providespace efficient data structures which answer queries in polylogarithmic time.

Privacy-Enhanced Reputation-Feedback Methods to Reduce Feedback  Extortion in Online Auctions

  In this paper, we study methods for improving the utility and privacy ofreputation scores for online auctions, such as used in eBay, so as to reducethe effectiveness of feedback extortion. The main ideas behind our techniquesare to use randomization and various schemes to escrow reputations scores untilappropriate external events occur. Depending on the degree of utility andprivacy needed, these external techniques could depend on the number and typeof reputation scores collected. Moreover, if additional privacy protection isneeded, then random sampling can be used with respect reputation scores in sucha way that reputation aggregates remain useful, but individual reputationscores are probabilistically hidden from users. Finally, we show that ifprivacy is also desired with respect to the the reputation aggregator, then wecan use zero-knowledge proofs for reputation comparisons.

Parallel Algorithms for Summing Floating-Point Numbers

  The problem of exactly summing n floating-point numbers is a fundamentalproblem that has many applications in large-scale simulations and computationalgeometry. Unfortunately, due to the round-off error in standard floating-pointoperations, this problem becomes very challenging. Moreover, all existingsolutions rely on sequential algorithms which cannot scale to the huge datasetsthat need to be processed.  In this paper, we provide several efficient parallel algorithms for summing nfloating point numbers, so as to produce a faithfully rounded floating-pointrepresentation of the sum. We present algorithms in PRAM, external-memory, andMapReduce models, and we also provide an experimental analysis of our MapReducealgorithms, due to their simplicity and practical efficiency.

Answering Spatial Multiple-Set Intersection Queries Using 2-3 Cuckoo  Hash-Filters

  We show how to answer spatial multiple-set intersection queries in O(n(logw)/w + kt) expected time, where n is the total size of the t sets involved inthe query, w is the number of bits in a memory word, k is the output size, andc is any fixed constant. This improves the asymptotic performance over previoussolutions and is based on an interesting data structure, known as 2-3 cuckoohash-filters. Our results apply in the word-RAM model (or practical RAM model),which allows for constant-time bit-parallel operations, such as bitwise AND,OR, NOT, and MSB (most-significant 1-bit), as exist in modern CPUs and GPUs.Our solutions apply to any multiple-set intersection queries in spatial datasets that can be reduced to one-dimensional range queries, such as spatial joinqueries for one-dimensional points or sets of points stored along space-fillingcurves, which are used in GIS applications.

Wear Minimization for Cuckoo Hashing: How Not to Throw a Lot of Eggs  into One Basket

  We study wear-leveling techniques for cuckoo hashing, showing that it ispossible to achieve a memory wear bound of $\log\log n+O(1)$ after theinsertion of $n$ items into a table of size $Cn$ for a suitable constant $C$using cuckoo hashing. Moreover, we study our cuckoo hashing method empirically,showing that it significantly improves on the memory wear performance forclassic cuckoo hashing and linear probing in practice.

Oblivious RAM Simulation with Efficient Worst-Case Access Overhead

  Oblivious RAM simulation is a method for achieving confidentiality andprivacy in cloud computing environments. It involves obscuring the accesspatterns to a remote storage so that the manager of that storage cannot inferinformation about its contents. Existing solutions typically involve smallamortized overheads for achieving this goal, but nevertheless involvepotentially huge variations in access times, depending on when they occur. Inthis paper, we show how to de-amortize oblivious RAM simulations, so that eachaccess takes a worst-case bounded amount of time.

Guard Placement For Wireless Localization

  Motivated by secure wireless networking, we consider the problem of placingfixed localizers that enable mobile communication devices to prove they belongto a secure region that is defined by the interior of a polygon. Each localizerviews an infinite wedge of the plane, and a device can prove membership in thesecure region if it is inside the wedges for a set of localizers whose commonintersection contains no points outside the polygon. This model leads to abroad class of new art gallery type problems, for which we provide upper andlower bounds.

Set-Difference Range Queries

  We introduce the problem of performing set-difference range queries, whereanswers to queries are set-theoretic symmetric differences between sets ofitems in two geometric ranges. We describe a general framework for answeringsuch queries based on a novel use of data-streaming sketches we call signedsymmetric-difference sketches. We show that such sketches can be realized usinginvertible Bloom filters (IBFs), which can be composed, differenced, andsearched so as to solve set-difference range queries in a wide range ofscenarios.

Scheduling Autonomous Vehicle Platoons Through an Unregulated  Intersection

  We study various versions of the problem of scheduling platoons of autonomousvehicles through an unregulated intersection, where an algorithm must schedulewhich platoons should wait so that others can go through, so as to minimize themaximum delay for any vehicle. We provide polynomial-time algorithms forconstructing such schedules for a $k$-way merge intersection, for constant $k$,and for a crossing intersection involving two-way traffic. We also show thatthe more general problem of scheduling autonomous platoons through anintersection that includes both a $k$-way merge, for non-constant $k$, and acrossing of two-way traffic is NP-complete.

External-Memory Network Analysis Algorithms for Naturally Sparse Graphs

  In this paper, we present a number of network-analysis algorithms in theexternal-memory model. We focus on methods for large naturally sparse graphs,that is, n-vertex graphs that have O(n) edges and are structured so that thissparsity property holds for any subgraph of such a graph. We give efficientexternal-memory algorithms for the following problems for such graphs: -Finding an approximate d-degeneracy ordering; - Finding a cycle of lengthexactly c; - Enumerating all maximal cliques. Such problems are of interest,for example, in the analysis of social networks, where they are used to studynetwork cohesion.

Achieving Good Angular Resolution in 3D Arc Diagrams

  We study a three-dimensional analogue to the well-known graph visualizationapproach known as arc diagrams. We provide several algorithms that achieve goodangular resolution for 3D arc diagrams, even for cases when the arcs mustproject to a given 2D straight-line drawing of the input graph. Our methodsmake use of various graph coloring algorithms, including an algorithm for a newcoloring problem, which we call localized edge coloring.

Parallel Equivalence Class Sorting: Algorithms, Lower Bounds, and  Distribution-Based Analysis

  We study parallel comparison-based algorithms for finding all equivalenceclasses of a set of $n$ elements, where sorting according to some total orderis not possible. Such scenarios arise, for example, in applications, such as indistributed computer security, where each of $n$ agents are working to identifythe private group to which they belong, with the only operation available tothem being a zero-knowledge pairwise-comparison (which is sometimes called a"secret handshake") that reveals only whether two agents are in the same groupor in different groups. We provide new parallel algorithms for this problem, aswell as new lower bounds and distribution-based analysis.

J-Viz: Sibling-First Recursive Graph Drawing for Visualizing Java  Bytecode

  We describe a graph visualization tool for visualizing Java bytecode. Ourtool, which we call J-Viz, visualizes connected directed graphs according to acanonical node ordering, which we call the sibling-first recursive (SFR)numbering. The particular graphs we consider are derived from applying Shiver'sk-CFA framework to Java bytecode, and our visualizer includes helpful linksbetween the nodes of an input graph and the Java bytecode that produced it, aswell as a decompiled version of that Java bytecode. We show through severalcase studies that the canonical drawing paradigm used in J-Viz is effective foridentifying potential security vulnerabilities and repeated use of the samecode in Java applications.

Improved Combinatorial Group Testing Algorithms for Real-World Problem  Sizes

  We study practically efficient methods for performing combinatorial grouptesting. We present efficient non-adaptive and two-stage combinatorial grouptesting algorithms, which identify the at most d items out of a given set of nitems that are defective, using fewer tests for all practical set sizes. Forexample, our two-stage algorithm matches the information theoretic lower boundfor the number of tests in a combinatorial group testing regimen.

Combinatorial Pair Testing: Distinguishing Workers from Slackers

  We formalize a problem we call combinatorial pair testing (CPT), which hasapplications to the identification of uncooperative or unproductiveparticipants in pair programming, massively distributed computing, andcrowdsourcing environments. We give efficient adaptive and nonadaptive CPTalgorithms and we show that our methods use an optimal number of testing roundsto within constant factors. We also provide an empirical evaluation of some ofour methods.

Privacy-Enhanced Methods for Comparing Compressed DNA Sequences

  In this paper, we study methods for improving the efficiency and privacy ofcompressed DNA sequence comparison computations, under various queryingscenarios. For instance, one scenario involves a querier, Bob, who wants totest if his DNA string, $Q$, is close to a DNA string, $Y$, owned by a dataowner, Alice, but Bob does not want to reveal $Q$ to Alice and Alice is willingto reveal $Y$ to Bob \emph{only if} it is close to $Q$. We describe aprivacy-enhanced method for comparing two compressed DNA sequences, which canbe used to achieve the goals of such a scenario. Our method involves areduction to set differencing, and we describe a privacy-enhanced protocol forset differencing that achieves absolute privacy for Bob (in the informationtheoretic sense), and a quantifiable degree of privacy protection for Alice.One of the important features of our protocols, which makes them ideally suitedto privacy-enhanced DNA sequence comparison problems, is that the communicationcomplexity of our solutions is proportional to a threshold that bounds thecardinality of the set differences that are of interest, rather than thecardinality of the sets involved (which correlates to the length of the DNAsequences). Moreover, in our protocols, the querier, Bob, can easily computethe set difference only if its cardinality is close to or below a specifiedthreshold.

Lombardi Drawings of Graphs

  We introduce the notion of Lombardi graph drawings, named after the Americanabstract artist Mark Lombardi. In these drawings, edges are represented ascircular arcs rather than as line segments or polylines, and the vertices haveperfect angular resolution: the edges are equally spaced around each vertex. Wedescribe algorithms for finding Lombardi drawings of regular graphs, graphs ofbounded degeneracy, and certain families of planar graphs.

Learning Character Strings via Mastermind Queries, with a Case Study  Involving mtDNA

  We study the degree to which a character string, $Q$, leaks details aboutitself any time it engages in comparison protocols with a strings provided by aquerier, Bob, even if those protocols are cryptographically guaranteed toproduce no additional information other than the scores that assess the degreeto which $Q$ matches strings offered by Bob. We show that such scenarios allowBob to play variants of the game of Mastermind with $Q$ so as to learn thecomplete identity of $Q$. We show that there are a number of efficientimplementations for Bob to employ in these Mastermind attacks, depending onknowledge he has about the structure of $Q$, which show how quickly he candetermine $Q$. Indeed, we show that Bob can discover $Q$ using a number ofrounds of test comparisons that is much smaller than the length of $Q$, underreasonable assumptions regarding the types of scores that are returned by thecryptographic protocols and whether he can use knowledge about the distributionthat $Q$ comes from. We also provide the results of a case study we performedon a database of mitochondrial DNA, showing the vulnerability of existingreal-world DNA data to the Mastermind attack.

On the Approximability of Geometric and Geographic Generalization and  the Min-Max Bin Covering Problem

  We study the problem of abstracting a table of data about individuals so thatno selection query can identify fewer than k individuals. We show that it isimpossible to achieve arbitrarily good polynomial-time approximations for anumber of natural variations of the generalization technique, unless P = NP,even when the table has only a single quasi-identifying attribute thatrepresents a geographic or unordered attribute:  Zip-codes: nodes of a planar graph generalized into connected subgraphs  GPS coordinates: points in R2 generalized into non-overlapping rectangles  Unordered data: text labels that can be grouped arbitrarily. In addition toimpossibility results, we provide approximation algorithms for these difficultsingle-attribute generalization problems, which, of course, apply tomultiple-attribute instances with one that is quasi-identifying. We showtheoretically and experimentally that our approximation algorithms can comereasonably close to optimal solutions. Incidentally, the generalization problemfor unordered data can be viewed as a novel type of bin packingproblem--min-max bin covering--which may be of independent interest.

Improved Adaptive Group Testing Algorithms with Applications to Multiple  Access Channels and Dead Sensor Diagnosis

  We study group-testing algorithms for resolving broadcast conflicts on amultiple access channel (MAC) and for identifying the dead sensors in a mobilead hoc wireless network. In group-testing algorithms, we are asked to identifyall the defective items in a set of items when we can test arbitrary subsets ofitems. In the standard group-testing problem, the result of a test isbinary--the tested subset either contains defective items or not. In the moregeneralized versions we study in this paper, the result of each test isnon-binary. For example, it may indicate whether the number of defective itemscontained in the tested subset is zero, one, or at least two. We give adaptivealgorithms that are provably more efficient than previous group testingalgorithms. We also show how our algorithms can be applied to solve conflictresolution on a MAC and dead sensor diagnosis. Dead sensor diagnosis poses aninteresting challenge compared to MAC resolution, because dead sensors are notlocally detectable, nor are they themselves active participants.

Zig-zag Sort: A Simple Deterministic Data-Oblivious Sorting Algorithm  Running in O(n log n) Time

  We describe and analyze Zig-zag Sort--a deterministic data-oblivious sortingalgorithm running in O(n log n) time that is arguably simpler than previouslyknown algorithms with similar properties, which are based on the AKS sortingnetwork. Because it is data-oblivious and deterministic, Zig-zag Sort can beimplemented as a simple O(n log n)-size sorting network, thereby providing asolution to an open problem posed by Incerpi and Sedgewick in 1985. Inaddition, Zig-zag Sort is a variant of Shellsort, and is, in fact, the firstdeterministic Shellsort variant running in O(n log n) time. The existence ofsuch an algorithm was posed as an open problem by Plaxton et al. in 1992 andalso by Sedgewick in 1996. More relevant for today, however, is the fact thatthe existence of a simple data-oblivious deterministic sorting algorithmrunning in O(n log n) time simplifies the inner-loop computation in severalproposed oblivious-RAM simulation methods (which utilize AKS sorting networks),and this, in turn, implies simplified mechanisms for privacy-preserving dataoutsourcing in several cloud computing applications. We provide bothconstructive and non-constructive implementations of Zig-zag Sort, based on theexistence of a circuit known as an epsilon-halver, such that the constantfactors in our constructive implementations are orders of magnitude smallerthan those for constructive variants of the AKS sorting network, which are alsobased on the use of epsilon-halvers.

Pipelined Algorithms to Detect Cheating in Long-Term Grid Computations

  This paper studies pipelined algorithms for protecting distributed gridcomputations from cheating participants, who wish to be rewarded for tasks theyreceive but don't perform. We present improved cheater detection algorithmsthat utilize natural delays that exist in long-term grid computations. Inparticular, we partition the sequence of grid tasks into two interleavedsequences of task rounds, and we show how to use those rounds to devise thefirst general-purpose scheme that can catch all cheaters, even when cheaterscollude. The main idea of this algorithm might at first seemcounter-intuitive--we have the participants check each other's work. A naiveimplementation of this approach would, of course, be susceptible to collusionattacks, but we show that by, adapting efficient solutions to the parallelprocessor diagnosis problem, we can tolerate collusions of lazy cheaters, evenif the number of such cheaters is a fraction of the total number ofparticipants. We also include a simple economic analysis of cheaters in gridcomputations and a parameterization of the main deterrent that can be usedagainst them--the probability of being caught.

Force-Directed Graph Drawing Using Social Gravity and Scaling

  Force-directed layout algorithms produce graph drawings by resolving a systemof emulated physical forces. We present techniques for using social gravity asan additional force in force-directed layouts, together with a scalingtechnique, to produce drawings of trees and forests, as well as more complexsocial networks. Social gravity assigns mass to vertices in proportion to theirnetwork centrality, which allows vertices that are more graph-theoreticallycentral to be visualized in physically central locations. Scaling varies thegravitational force throughout the simulation, and reduces crossings relativeto unscaled gravity. In addition to providing this algorithmic framework, weapply our algorithms to social networks produced by Mark Lombardi, and we showhow social gravity can be incorporated into force-directed Lombardi-styledrawings.

Privacy-Preserving Group Data Access via Stateless Oblivious RAM  Simulation

  We study the problem of providing privacy-preserving access to an outsourcedhonest-but-curious data repository for a group of trusted users. We show thatsuch privacy-preserving data access is possible using a combination ofprobabilistic encryption, which directly hides data values, and statelessoblivious RAM simulation, which hides the pattern of data accesses. We givesimulations that have only an $O(\log n)$ amortized time overhead forsimulating a RAM algorithm, $\cal A$, that has a memory of size $n$, using ascheme that is data-oblivious with very high probability assuming thesimulation has access to a private workspace of size $O(n^\nu)$, for any givenfixed constant $\nu>0$. This simulation makes use of pseudorandom hashfunctions and is based on a novel hierarchy of cuckoo hash tables that allshare a common stash. We also provide results from an experimental simulationof this scheme, showing its practicality. In addition, in a result that may beof some theoretical interest, we also show that one can eliminate thedependence on pseudorandom hash functions in our simulation while having theoverhead rise to be $O(\log^2 n)$.

External-Memory Multimaps

  Many data structures support dictionaries, also known as maps or associativearrays, which store and manage a set of key-value pairs. A \emph{multimap} isgeneralization that allows multiple values to be associated with the same key.For example, the inverted file data structure that is used prevalently in theinfrastructure supporting search engines is a type of multimap, where words areused as keys and document pointers are used as values. We study the multimapabstract data type and how it can be implemented efficiently online in externalmemory frameworks, with constant expected I/O performance. The key techniqueused to achieve our results is a combination of cuckoo hashing using bucketsthat hold multiple items with a multiqueue implementation to cope with varyingnumbers of values per key. Our external-memory results are for the standardtwo-level memory model.

Oblivious Storage with Low I/O Overhead

  We study oblivious storage (OS), a natural way to model privacy-preservingdata outsourcing where a client, Alice, stores sensitive data at anhonest-but-curious server, Bob. We show that Alice can hide both the content ofher data and the pattern in which she accesses her data, with high probability,using a method that achieves O(1) amortized rounds of communication between herand Bob for each data access. We assume that Alice and Bob exchange smallmessages, of size $O(N^{1/c})$, for some constant $c\ge2$, in a single round,where $N$ is the size of the data set that Alice is storing with Bob. We alsoassume that Alice has a private memory of size $2N^{1/c}$. These assumptionsmodel real-world cloud storage scenarios, where trade-offs occur betweenlatency, bandwidth, and the size of the client's private memory.

Choosing Colors for Geometric Graphs via Color Space Embeddings

  Graph drawing research traditionally focuses on producing geometricembeddings of graphs satisfying various aesthetic constraints. After thegeometric embedding is specified, there is an additional step that is oftenoverlooked or ignored: assigning display colors to the graph's vertices. Westudy the additional aesthetic criterion of assigning distinct colors tovertices of a geometric graph so that the colors assigned to adjacent verticesare as different from one another as possible. We formulate this as a probleminvolving perceptual metrics in color space and we develop algorithms forsolving this problem by embedding the graph in color space. We also present anapplication of this work to a distributed load-balancing visualization problem.

Capturing Lombardi Flow in Orthogonal Drawings by Minimizing the Number  of Segments

  Inspired by the artwork of Mark Lombardi, we study the problem ofconstructing orthogonal drawings where a small number of horizontal andvertical line segments covers all vertices. We study two problems on orthogonaldrawings of planar graphs, one that minimizes the total number of line segmentsand another that minimizes the number of line segments that cover all thevertices. We show that the first problem can be solved by a non-trivialmodification of the flow-network orthogonal bend-minimization algorithm ofTamassia, resulting in a polynomial-time algorithm. We show that the secondproblem is NP-hard even for planar graphs with maximum degree 3. Given thisresult, we then address this second optimization problem for trees andseries-parallel graphs with maximum degree 3. For both graph classes, we givepolynomial-time algorithms for upward orthogonal drawings with the minimumnumber of segments covering the vertices.

Models and Algorithms for Graph Watermarking

  We introduce models and algorithmic foundations for graph watermarking. Ourframeworks include security definitions and proofs, as well ascharacterizations when graph watermarking is algorithmically feasible, in spiteof the fact that the general problem is NP-complete by simple reductions fromthe subgraph isomorphism or graph edit distance problems. In the digitalwatermarking of many types of files, an implicit step in the recovery of awatermark is the mapping of individual pieces of data, such as image pixels ormovie frames, from one object to another. In graphs, this step corresponds toapproximately matching vertices of one graph to another based on graphinvariants such as vertex degree. Our approach is based on characterizing thefeasibility of graph watermarking in terms of keygen, marking, andidentification functions defined over graph families with known distributions.We demonstrate the strength of this approach with exemplary watermarkingschemes for two random graph models, the classic Erd\H{o}s-R\'{e}nyi model anda random power-law graph model, both of which are used to model real-worldnetworks.

Planar Drawings of Higher-Genus Graphs

  In this paper, we give polynomial-time algorithms that can take a graph Gwith a given combinatorial embedding on an orientable surface S of genus g andproduce a planar drawing of G in R^2, with a bounding face defined by apolygonal schema P for S. Our drawings are planar, but they allow for multiplecopies of vertices and edges on P's boundary, which is a common way ofvisualizing higher-genus graphs in the plane. Our drawings can be defined withrespect to either a canonical polygonal schema or a polygonal cutset schema,which provides an interesting tradeoff, since canonical schemas have fewersides, and have a nice topological structure, but they can have many morerepeated vertices and edges than general polygonal cutsets. As a side note, weshow that it is NP-complete to determine whether a given graph embedded in agenus-g surface has a set of 2g fundamental cycles with vertex-disjointinteriors, which would be desirable from a graph-drawing perspective.

