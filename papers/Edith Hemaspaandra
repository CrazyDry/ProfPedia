All Superlinear Inverse Schemes are coNP-Hard

  How hard is it to invert NP-problems? We show that all superlinearly
certified inverses of NP problems are coNP-hard. To do so, we develop a novel
proof technique that builds diagonalizations against certificates directly into
a circuit.


A Richer Understanding of the Complexity of Election Systems

  We provide an overview of some recent progress on the complexity of election
systems. The issues studied include the complexity of the winner, manipulation,
bribery, and control problems.


Downward Collapse from a Weaker Hypothesis

  Hemaspaandra et al. proved that, for $m > 0$ and $0 < i < k - 1$: if
$\Sigma_i^p \BoldfaceDelta DIFF_m(\Sigma_k^p)$ is closed under complementation,
then $DIFF_m(\Sigma_k^p) = coDIFF_m(\Sigma_k^p)$. This sharply asymmetric
result fails to apply to the case in which the hypothesis is weakened by
allowing the $\Sigma_i^p$ to be replaced by any class in its difference
hierarchy. We so extend the result by proving that, for $s,m > 0$ and $0 < i <
k - 1$: if $DIFF_s(\Sigma_i^p) \BoldfaceDelta DIFF_m(\Sigma_k^p)$ is closed
under complementation, then $DIFF_m(\Sigma_k^p) = coDIFF_m(\Sigma_k^p)$.


On the Power of Positive Turing Reductions

  In the early 1980s, Selman's seminal work on positive Turing reductions
showed that positive Turing reduction to NP yields no greater computational
power than NP itself. Thus, positive Turing and Turing reducibility to NP
differ sharply unless the polynomial hierarchy collapses.
  We show that the situation is quite different for DP, the next level of the
boolean hierarchy. In particular, positive Turing reduction to DP already
yields all (and only) sets Turing reducibility to NP. Thus, positive Turing and
Turing reducibility to DP yield the same class. Additionally, we show that an
even weaker class, P(NP[1]), can be substituted for DP in this context.


Almost-Everywhere Superiority for Quantum Computing

  Simon as extended by Brassard and H{\o}yer shows that there are tasks on
which polynomial-time quantum machines are exponentially faster than each
classical machine infinitely often. The present paper shows that there are
tasks on which polynomial-time quantum machines are exponentially faster than
each classical machine almost everywhere.


Weighted Electoral Control

  Although manipulation and bribery have been extensively studied under
weighted voting, there has been almost no work done on election control under
weighted voting. This is unfortunate, since weighted voting appears in many
important natural settings. In this paper, we study the complexity of
controlling the outcome of weighted elections through adding and deleting
voters. We obtain polynomial-time algorithms, NP-completeness results, and for
many NP-complete cases, approximation algorithms. In particular, for scoring
rules we completely characterize the complexity of weighted voter control. Our
work shows that for quite a few important cases, either polynomial-time exact
algorithms or polynomial-time approximation algorithms exist.


What's Up with Downward Collapse: Using the Easy-Hard Technique to Link
  Boolean and Polynomial Hierarchy Collapses

  During the past decade, nine papers have obtained increasingly strong
consequences from the assumption that boolean or bounded-query hierarchies
collapse. The final four papers of this nine-paper progression actually achieve
downward collapse---that is, they show that high-level collapses induce
collapses at (what beforehand were thought to be) lower complexity levels. For
example, for each $k\geq 2$ it is now known that if $\psigkone=\psigktwo$ then
$\ph=\sigmak$. This article surveys the history, the results, and the
technique---the so-called easy-hard method---of these nine papers.


A Downward Collapse within the Polynomial Hierarchy

  Downward collapse (a.k.a. upward separation) refers to cases where the
equality of two larger classes implies the equality of two smaller classes. We
provide an unqualified downward collapse result completely within the
polynomial hierarchy. In particular, we prove that, for k > 2, if $\psigkone =
\psigktwo$ then $\sigmak = \pik = \ph$. We extend this to obtain a more general
downward collapse result.


A Simplest Undecidable Modal Logic

  Modal logics are widely used in computer science. The complexity of their
satisfiability problems has been an active field of research since the 1970s.
We prove that even very "simple" modal logics can be undecidable: We show that
there is an undecidable modal logic that can be obtained by restricting the
allowed models with a first-order formula in which only universal quantifiers
appear.


Dichotomy Theorems for Alternation-Bounded Quantified Boolean Formulas

  In 1978, Schaefer proved his famous dichotomy theorem for generalized
satisfiability problems. He defined an infinite number of propositional
satisfiability problems, showed that all these problems are either in P or
NP-complete, and gave a simple criterion to determine which of the two cases
holds. This result is surprising in light of Ladner's theorem, which implies
that there are an infinite number of complexity classes between P and
NP-complete (under the assumption that P is not equal to NP).
  Schaefer also stated a dichotomy theorem for quantified generalized Boolean
formulas, but this theorem was only recently proven by Creignou, Khanna, and
Sudan, and independently by Dalmau: Determining truth of quantified Boolean
formulas is either PSPACE-complete or in P.
  This paper looks at alternation-bounded quantified generalized Boolean
formulas. In their unrestricted forms, these problems are the canonical
problems complete for the levels of the polynomial hierarchy. In this paper, we
prove dichotomy theorems for alternation-bounded quantified generalized Boolean
formulas, by showing that these problems are either $\Sigma_i^p$-complete or in
P, and we give a simple criterion to determine which of the two cases holds.
This is the first result that obtains dichotomy for an infinite number of
classes at once.


An Introduction to Query Order

  Hemaspaandra, Hempel, and Wechsung [cs.CC/9909020] raised the following
questions: If one is allowed one question to each of two different information
sources, does the order in which one asks the questions affect the class of
problems that one can solve with the given access? If so, which order yields
the greater computational power?
  The answers to these questions have been learned-inasfar as they can be
learned without resolving whether or not the polynomial hierarchy collapses-for
both the polynomial hierarchy and the boolean hierarchy. In the polynomial
hierarchy, query order never matters. In the boolean hierarchy, query order
sometimes does not matter and, unless the polynomial hierarchy collapses,
sometimes does matter. Furthermore, the study of query order has yielded
dividends in seemingly unrelated areas, such as bottleneck computations and
downward translation of equality.
  In this article, we present some of the central results on query order. The
article is written in such a way as to encourage the reader to try his or her
own hand at proving some of these results. We also give literature pointers to
the quickly growing set of related results and applications.


Query Order and the Polynomial Hierarchy

  Hemaspaandra, Hempel, and Wechsung [cs.CC/9909020] initiated the field of
query order, which studies the ways in which computational power is affected by
the order in which information sources are accessed. The present paper studies,
for the first time, query order as it applies to the levels of the polynomial
hierarchy. We prove that the levels of the polynomial hierarchy are
order-oblivious. Yet, we also show that these ordered query classes form new
levels in the polynomial hierarchy unless the polynomial hierarchy collapses.
We prove that all leaf language classes - and thus essentially all standard
complexity classes - inherit all order-obliviousness results that hold for P.


Dichotomy for Voting Systems

  Scoring protocols are a broad class of voting systems. Each is defined by a
vector $(\alpha_1,\alpha_2,...,\alpha_m)$, $\alpha_1 \geq \alpha_2 \geq >...
\geq \alpha_m$, of integers such that each voter contributes $\alpha_1$ points
to his/her first choice, $\alpha_2$ points to his/her second choice, and so on,
and any candidate receiving the most points is a winner.
  What is it about scoring-protocol election systems that makes some have the
desirable property of being NP-complete to manipulate, while others can be
manipulated in polynomial time? We find the complete, dichotomizing answer:
Diversity of dislike. Every scoring-protocol election system having two or more
point values assigned to candidates other than the favorite--i.e., having
$||\{\alpha_i \condition 2 \leq i \leq m\}||\geq 2$--is NP-complete to
manipulate. Every other scoring-protocol election system can be manipulated in
polynomial time. In effect, we show that--other than trivial systems (where all
candidates alway tie), plurality voting, and plurality voting's transparently
disguised translations--\emph{every} scoring-protocol election system is
NP-complete to manipulate.


The Complexity of Kings

  A king in a directed graph is a node from which each node in the graph can be
reached via paths of length at most two. There is a broad literature on
tournaments (completely oriented digraphs), and it has been known for more than
half a century that all tournaments have at least one king [Lan53]. Recently,
kings have proven useful in theoretical computer science, in particular in the
study of the complexity of the semifeasible sets [HNP98,HT05] and in the study
of the complexity of reachability problems [Tan01,NT02].
  In this paper, we study the complexity of recognizing kings. For each
succinctly specified family of tournaments, the king problem is known to belong
to $\Pi_2^p$ [HOZZ]. We prove that this bound is optimal: We construct a
succinctly specified tournament family whose king problem is
$\Pi_2^p$-complete. It follows easily from our proof approach that the problem
of testing kingship in succinctly specified graphs (which need not be
tournaments) is $\Pi_2^p$-complete. We also obtain $\Pi_2^p$-completeness
results for k-kings in succinctly specified j-partite tournaments, $k,j \geq
2$, and we generalize our main construction to show that $\Pi_2^p$-completeness
holds for testing k-kingship in succinctly specified families of tournaments
for all $k \geq 2$.


Hybrid Elections Broaden Complexity-Theoretic Resistance to Control

  Electoral control refers to attempts by an election's organizer ("the chair")
to influence the outcome by adding/deleting/partitioning voters or candidates.
The groundbreaking work of Bartholdi, Tovey, and Trick [BTT92] on
(constructive) control proposes computational complexity as a means of
resisting control attempts: Look for election systems where the chair's task in
seeking control is itself computationally infeasible.
  We introduce and study a method of combining two or more candidate-anonymous
election schemes in such a way that the combined scheme possesses all the
resistances to control (i.e., all the NP-hardnesses of control) possessed by
any of its constituents: It combines their strengths. From this and new
resistance constructions, we prove for the first time that there exists an
election scheme that is resistant to all twenty standard types of electoral
control.


Search versus Decision for Election Manipulation Problems

  Most theoretical definitions about the complexity of manipulating elections
focus on the decision problem of recognizing which instances can be
successfully manipulated, rather than the search problem of finding the
successful manipulative actions. Since the latter is a far more natural goal
for manipulators, that definitional focus may be misguided if these two
complexities can differ. Our main result is that they probably do differ: If
integer factoring is hard, then for election manipulation, election bribery,
and some types of election control, there are election systems for which
recognizing which instances can be successfully manipulated is in polynomial
time but producing the successful manipulations cannot be done in polynomial
time.


Control in the Presence of Manipulators: Cooperative and Competitive
  Cases

  Control and manipulation are two of the most studied types of attacks on
elections. In this paper, we study the complexity of control attacks on
elections in which there are manipulators. We study both the case where the
"chair" who is seeking to control the election is allied with the manipulators,
and the case where the manipulators seek to thwart the chair. In the latter
case, we see that the order of play substantially influences the complexity. We
prove upper bounds, holding over every election system with a polynomial-time
winner problem, for all standard control cases, and some of these bounds are at
the second or third level of the polynomial hierarchy, and we provide matching
lower bounds to prove these tight. Nonetheless, for important natural systems
the complexity can be much lower. We prove that for approval and plurality
elections, the complexity of even competitive clashes between a controller and
manipulators falls far below those high bounds, even as low as polynomial time.
Yet for a Borda-voting case we show that such clashes raise the complexity
unless NP = coNP.


X THEN X: Manipulation of Same-System Runoff Elections

  Do runoff elections, using the same voting rule as the initial election but
just on the winning candidates, increase or decrease the complexity of
manipulation? Does allowing revoting in the runoff increase or decrease the
complexity relative to just having a runoff without revoting? For both weighted
and unweighted voting, we show that even for election systems with simple
winner problems the complexity of manipulation, manipulation with runoffs, and
manipulation with revoting runoffs are independent, in the abstract. On the
other hand, for some important, well-known election systems we determine what
holds for each of these cases. For no such systems do we find runoffs lowering
complexity, and for some we find that runoffs raise complexity. Ours is the
first paper to show that for natural, unweighted election systems, runoffs can
increase the manipulation complexity.


Complexity Dichotomies for Unweighted Scoring Rules

  Scoring systems are an extremely important class of election systems. We
study the complexity of manipulation, constructive control by deleting voters
(CCDV), and bribery for scoring systems.
  For manipulation, we show that for all scoring rules with a constant number
of different coefficients, manipulation is in P. And we conjecture that there
is no dichotomy theorem.
  On the other hand, we obtain dichotomy theorems for CCDV and bribery problem.
More precisely, we show that both of these problems are easy for 1-approval,
2-approval, 1-veto, 2-veto, 3-veto, generalized 2-veto, and (2,1,...,1,0), and
hard in all other cases. These results are the "dual" of the dichotomy theorem
for the constructive control by adding voters (CCAV) problem from
(Hemaspaandra, Hemaspaandra, Schnoor, AAAI 2014), but do not at all follow from
that result. In particular, proving hardness for CCDV is harder than for CCAV
since we do not have control over what the controller can delete, and proving
easiness for bribery tends to be harder than for control, since bribery can be
viewed as control followed by manipulation.


Credimus

  We believe that economic design and computational complexity---while already
important to each other---should become even more important to each other with
each passing year. But for that to happen, experts in on the one hand such
areas as social choice, economics, and political science and on the other hand
computational complexity will have to better understand each other's
worldviews.
  This article, written by two complexity theorists who also work in
computational social choice theory, focuses on one direction of that process by
presenting a brief overview of how most computational complexity theorists view
the world. Although our immediate motivation is to make the lens through which
complexity theorists see the world be better understood by those in the social
sciences, we also feel that even within computer science it is very important
for nontheoreticians to understand how theoreticians think, just as it is
equally important within computer science for theoreticians to understand how
nontheoreticians think.


Using the No-Search Easy-Hard Technique for Downward Collapse

  The top part of the preceding figure [figure appears in actual paper] shows
some classes from the (truth-table) bounded-query and boolean hierarchies. It
is well-known that if either of these hierarchies collapses at a given level,
then all higher levels of that hierarchy collapse to that same level. This is a
standard ``upward translation of equality'' that has been known for over a
decade. The issue of whether these hierarchies can translate equality {\em
downwards\/} has proven vastly more challenging. In particular, with regard to
the figure above, consider the following claim:
  $$P_{m-tt}^{\Sigma_k^p} = P_{m+1-tt}^{\Sigma_k^p} \implies
  DIFF_m(\Sigma_k^p) coDIFF_m(\Sigma_k^p) = BH(\Sigma_k^p). (*) $$
  This claim, if true, says that equality translates downwards between levels
of the bounded-query hierarchy and the boolean hierarchy levels that (before
the fact) are immediately below them.
  Until recently, it was not known whether (*) {\em ever\/} held, except for
the degenerate cases $m=0$ and $k=0$. Then Hemaspaandra, Hemaspaandra, and
Hempel \cite{hem-hem-hem:j:downward-translation} proved that (*) holds for all
$m$, for $k > 2$. Buhrman and Fortnow~\cite{buh-for:j:two-queries} then showed
that, when $k=2$, (*) holds for the case $m = 1$. In this paper, we prove that
for the case $k=2$, (*) holds for all values of $m$. Since there is an oracle
relative to which ``for $k=1$, (*) holds for all $m$'' fails
\cite{buh-for:j:two-queries}, our achievement of the $k=2$ case cannot to be
strengthened to $k=1$ by any relativizable proof technique. The new downward
translation we obtain also tightens the collapse in the polynomial hierarchy
implied by a collapse in the bounded-query hierarchy of the second level of the
polynomial hierarchy.


Recognizing When Heuristics Can Approximate Minimum Vertex Covers Is
  Complete for Parallel Access to NP

  For both the edge deletion heuristic and the maximum-degree greedy heuristic,
we study the problem of recognizing those graphs for which that heuristic can
approximate the size of a minimum vertex cover within a constant factor of r,
where r is a fixed rational number. Our main results are that these problems
are complete for the class of problems solvable via parallel access to NP. To
achieve these main results, we also show that the restriction of the vertex
cover problem to those graphs for which either of these heuristics can find an
optimal solution remains NP-hard.


Isomorphic Implication

  We study the isomorphic implication problem for Boolean constraints. We show
that this is a natural analog of the subgraph isomorphism problem. We prove
that, depending on the set of constraints, this problem is in P, NP-complete,
or NP-hard, coNP-hard, and in parallel access to NP. We show how to extend the
NP-hardness and coNP-hardness to hardness for parallel access to NP for some
cases, and conjecture that this can be done in all cases.


On the Complexity of Elementary Modal Logics

  Modal logics are widely used in computer science. The complexity of modal
satisfiability problems has been investigated since the 1970s, usually proving
results on a case-by-case basis. We prove a very general classification for a
wide class of relevant logics: Many important subclasses of modal logics can be
obtained by restricting the allowed models with first-order Horn formulas. We
show that the satisfiability problem for each of these logics is either
NP-complete or PSPACE-hard, and exhibit a simple classification criterion.
Further, we prove matching PSPACE upper bounds for many of the PSPACE-hard
logics.


Minimization for Generalized Boolean Formulas

  The minimization problem for propositional formulas is an important
optimization problem in the second level of the polynomial hierarchy. In
general, the problem is Sigma-2-complete under Turing reductions, but
restricted versions are tractable. We study the complexity of minimization for
formulas in two established frameworks for restricted propositional logic: The
Post framework allowing arbitrarily nested formulas over a set of Boolean
connectors, and the constraint setting, allowing generalizations of CNF
formulas. In the Post case, we obtain a dichotomy result: Minimization is
solvable in polynomial time or coNP-hard. This result also applies to Boolean
circuits. For CNF formulas, we obtain new minimization algorithms for a large
class of formulas, and give strong evidence that we have covered all
polynomial-time cases.


Complexity of Manipulative Actions When Voting with Ties

  Most of the computational study of election problems has assumed that each
voter's preferences are, or should be extended to, a total order. However in
practice voters may have preferences with ties. We study the complexity of
manipulative actions on elections where voters can have ties, extending the
definitions of the election systems (when necessary) to handle voters with
ties. We show that for natural election systems allowing ties can both increase
and decrease the complexity of manipulation and bribery, and we state a general
result on the effect of voters with ties on the complexity of control.


The Complexity of Poor Man's Logic

  Motivated by description logics, we investigate what happens to the
complexity of modal satisfiability problems if we only allow formulas built
from literals, $\wedge$, $\Diamond$, and $\Box$. Previously, the only known
result was that the complexity of the satisfiability problem for K dropped from
PSPACE-complete to coNP-complete (Schmidt-Schauss and Smolka, 1991 and Donini
et al., 1992). In this paper we show that not all modal logics behave like K.
In particular, we show that the complexity of the satisfiability problem with
respect to frames in which each world has at least one successor drops from
PSPACE-complete to P, but that in contrast the satisfiability problem with
respect to the class of frames in which each world has at most two successors
remains PSPACE-complete. As a corollary of the latter result, we also solve the
open problem from Donini et al.'s complexity classification of description
logics (Donini et al., 1997). In the last section, we classify the complexity
of the satisfiability problem for K for all other restrictions on the set of
operators.


Exact Analysis of Dodgson Elections: Lewis Carroll's 1876 Voting System
  is Complete for Parallel Access to NP

  In 1876, Lewis Carroll proposed a voting system in which the winner is the
candidate who with the fewest changes in voters' preferences becomes a
Condorcet winner---a candidate who beats all other candidates in pairwise
majority-rule elections. Bartholdi, Tovey, and Trick provided a lower
bound---NP-hardness---on the computational complexity of determining the
election winner in Carroll's system. We provide a stronger lower bound and an
upper bound that matches our lower bound. In particular, determining the winner
in Carroll's system is complete for parallel access to NP, i.e., it is complete
for $\thetatwo$, for which it becomes the most natural complete problem known.
It follows that determining the winner in Carroll's elections is not
NP-complete unless the polynomial hierarchy collapses.


Raising NP Lower Bounds to Parallel NP Lower Bounds

  A decade ago, a beautiful paper by Wagner developed a ``toolkit'' that in
certain cases allows one to prove problems hard for parallel access to NP.
However, the problems his toolkit applies to most directly are not overly
natural. During the past year, problems that previously were known only to be
NP-hard or coNP-hard have been shown to be hard even for the class of sets
solvable via parallel access to NP. Many of these problems are longstanding and
extremely natural, such as the Minimum Equivalent Expression problem (which was
the original motivation for creating the polynomial hierarchy), the problem of
determining the winner in the election system introduced by Lewis Carroll in
1876, and the problem of determining on which inputs heuristic algorithms
perform well. In the present article, we survey this recent progress in raising
lower bounds.


R_{1-tt}^{SN}(NP) Distinguishes Robust Many-One and Turing Completeness

  Do complexity classes have many-one complete sets if and only if they have
Turing-complete sets? We prove that there is a relativized world in which a
relatively natural complexity class-namely a downward closure of NP, \rsnnp -
has Turing-complete sets but has no many-one complete sets. In fact, we show
that in the same relativized world this class has 2-truth-table complete sets
but lacks 1-truth-table complete sets. As part of the groundwork for our
result, we prove that \rsnnp has many equivalent forms having to do with
ordered and parallel access to $\np$ and $\npinterconp$.


Translating Equality Downwards

  Downward translation of equality refers to cases where a collapse of some
pair of complexity classes would induce a collapse of some other pair of
complexity classes that (a priori) one expects are smaller. Recently, the first
downward translation of equality was obtained that applied to the polynomial
hierarchy-in particular, to bounded access to its levels [cs.CC/9910007]. In
this paper, we provide a much broader downward translation that extends not
only that downward translation but also that translation's elegant enhancement
by Buhrman and Fortnow. Our work also sheds light on previous research on the
structure of refined polynomial hierarchies, and strengthens the connection
between the collapse of bounded query hierarchies and the collapse of the
polynomial hierarchy.


Multimode Control Attacks on Elections

  In 1992, Bartholdi, Tovey, and Trick opened the study of control attacks on
elections---attempts to improve the election outcome by such actions as
adding/deleting candidates or voters. That work has led to many results on how
algorithms can be used to find attacks on elections and how
complexity-theoretic hardness results can be used as shields against attacks.
However, all the work in this line has assumed that the attacker employs just a
single type of attack. In this paper, we model and study the case in which the
attacker launches a multipronged (i.e., multimode) attack. We do so to more
realistically capture the richness of real-life settings. For example, an
attacker might simultaneously try to suppress some voters, attract new voters
into the election, and introduce a spoiler candidate. Our model provides a
unified framework for such varied attacks, and by constructing polynomial-time
multiprong attack algorithms we prove that for various election systems even
such concerted, flexible attacks can be perfectly planned in deterministic
polynomial time.


The Complexity of Manipulative Attacks in Nearly Single-Peaked
  Electorates

  Many electoral bribery, control, and manipulation problems (which we will
refer to in general as "manipulative actions" problems) are NP-hard in the
general case. It has recently been noted that many of these problems fall into
polynomial time if the electorate is single-peaked (i.e., is polarized along
some axis/issue). However, real-world electorates are not truly single-peaked.
There are usually some mavericks, and so real-world electorates tend to merely
be nearly single-peaked. This paper studies the complexity of
manipulative-action algorithms for elections over nearly single-peaked
electorates, for various notions of nearness and various election systems. We
provide instances where even one maverick jumps the manipulative-action
complexity up to $\np$-hardness, but we also provide many instances where a
reasonable number of mavericks can be tolerated without increasing the
manipulative-action complexity.


The Complexity of Controlling Candidate-Sequential Elections

  Candidate control of elections is the study of how adding or removing
candidates can affect the outcome. However, the traditional study of the
complexity of candidate control is in the model in which all candidates and
votes are known up front. This paper develops a model for studying online
control for elections where the structure is sequential with respect to the
candidates, and in which the decision regarding adding and deleting must be
irrevocably made at the moment the candidate is presented. We show that great
complexity---PSPACE-completeness---can occur in this setting, but we also
provide within this setting polynomial-time algorithms for the most important
of election systems, plurality.


Complexity Results in Graph Reconstruction

  We investigate the relative complexity of the graph isomorphism problem (GI)
and problems related to the reconstruction of a graph from its vertex-deleted
or edge-deleted subgraphs (in particular, deck checking (DC) and legitimate
deck (LD) problems). We show that these problems are closely related for all
amounts $c \geq 1$ of deletion:
  1) $GI \equiv^{l}_{iso} VDC_{c}$, $GI \equiv^{l}_{iso} EDC_{c}$, $GI
\leq^{l}_{m} LVD_c$, and $GI \equiv^{p}_{iso} LED_c$.
  2) For all $k \geq 2$, $GI \equiv^{p}_{iso} k-VDC_c$ and $GI \equiv^{p}_{iso}
k-EDC_c$.
  3) For all $k \geq 2$, $GI \leq^{l}_{m} k-LVD_c$.
  4)$GI \equiv^{p}_{iso} 2-LVC_c$.
  5) For all $k \geq 2$, $GI \equiv^{p}_{iso} k-LED_c$.
  For many of these results, even the $c = 1$ case was not previously known.
  Similar to the definition of reconstruction numbers $vrn_{\exists}(G)$ [HP85]
and $ern_{\exists}(G)$ (see page 120 of [LS03]), we introduce two new graph
parameters, $vrn_{\forall}(G)$ and $ern_{\forall}(G)$, and give an example of a
family $\{G_n\}_{n \geq 4}$ of graphs on $n$ vertices for which
$vrn_{\exists}(G_n) < vrn_{\forall}(G_n)$. For every $k \geq 2$ and $n \geq 1$,
we show that there exists a collection of $k$ graphs on $(2^{k-1}+1)n+k$
vertices with $2^{n}$ 1-vertex-preimages, i.e., one has families of graph
collections whose number of 1-vertex-preimages is huge relative to the size of
the graphs involved.


Anyone but Him: The Complexity of Precluding an Alternative

  Preference aggregation in a multiagent setting is a central issue in both
human and computer contexts. In this paper, we study in terms of complexity the
vulnerability of preference aggregation to destructive control. That is, we
study the ability of an election's chair to, through such mechanisms as
voter/candidate addition/suppression/partition, ensure that a particular
candidate (equivalently, alternative) does not win. And we study the extent to
which election systems can make it impossible, or computationally costly
(NP-complete), for the chair to execute such control. Among the systems we
study--plurality, Condorcet, and approval voting--we find cases where systems
immune or computationally resistant to a chair choosing the winner nonetheless
are vulnerable to the chair blocking a victory. Beyond that, we see that among
our studied systems no one system offers the best protection against
destructive control. Rather, the choice of a preference aggregation system will
depend closely on which types of control one wishes to be protected against. We
also find concrete cases where the complexity of or susceptibility to control
varies dramatically based on the choice among natural tie-handling rules.


How Hard Is Bribery in Elections?

  We study the complexity of influencing elections through bribery: How
computationally complex is it for an external actor to determine whether by a
certain amount of bribing voters a specified candidate can be made the
election's winner? We study this problem for election systems as varied as
scoring protocols and Dodgson voting, and in a variety of settings regarding
homogeneous-vs.-nonhomogeneous electorate bribability,
bounded-size-vs.-arbitrary-sized candidate sets, weighted-vs.-unweighted
voters, and succinct-vs.-nonsuccinct input specification. We obtain both
polynomial-time bribery algorithms and proofs of the intractability of bribery,
and indeed our results show that the complexity of bribery is extremely
sensitive to the setting. For example, we find settings in which bribery is
NP-complete but manipulation (by voters) is in P, and we find settings in which
bribing weighted voters is NP-complete but bribing voters with individual bribe
thresholds is in P. For the broad class of elections (including plurality,
Borda, k-approval, and veto) known as scoring protocols, we prove a dichotomy
result for bribery of weighted voters: We find a simple-to-evaluate condition
that classifies every case as either NP-complete or in P.


Llull and Copeland Voting Computationally Resist Bribery and Control

  The only systems previously known to be resistant to all the standard control
types were highly artificial election systems created by hybridization. We
study a parameterized version of Copeland voting, denoted by Copeland^\alpha,
where the parameter \alpha is a rational number between 0 and 1 that specifies
how ties are valued in the pairwise comparisons of candidates. We prove that
Copeland^{0.5}, the system commonly referred to as "Copeland voting," provides
full resistance to constructive control, and we prove the same for
Copeland^\alpha, for all rational \alpha, 0 < \alpha < 1. Copeland voting is
the first natural election system proven to have full resistance to
constructive control. We also prove that both Copeland^1 (Llull elections) and
Copeland^0 are resistant to all standard types of constructive control other
than one variant of addition of candidates. Moreover, we show that for each
rational \alpha, 0 \leq \alpha \leq 1, Copeland^\alpha voting is fully
resistant to bribery attacks, and we establish fixed-parameter tractability of
bounded-case control for Copeland^\alpha. We also study Copeland^\alpha
elections under more flexible models such as microbribery and extended control
and we integrate the potential irrationality of voter preferences into many of
our results.


A Control Dichotomy for Pure Scoring Rules

  Scoring systems are an extremely important class of election systems. A
length-$m$ (so-called) scoring vector applies only to $m$-candidate elections.
To handle general elections, one must use a family of vectors, one per length.
The most elegant approach to making sure such families are "family-like" is the
recently introduced notion of (polynomial-time uniform) pure scoring rules
[Betzler and Dorn 2010], where each scoring vector is obtained from its
precursor by adding one new coefficient. We obtain the first dichotomy theorem
for pure scoring rules for a control problem. In particular, for constructive
control by adding voters (CCAV), we show that CCAV is solvable in polynomial
time for $k$-approval with $k \leq 3$, $k$-veto with $k \leq 2$, every pure
scoring rule in which only the two top-rated candidates gain nonzero scores,
and a particular rule that is a "hybrid" of 1-approval and 1-veto. For all
other pure scoring rules, CCAV is NP-complete. We also investigate the
descriptive richness of different models for defining pure scoring rules,
proving how more rule-generation time gives more rules, proving that rationals
give more rules than do the natural numbers, and proving that some restrictions
previously thought to be "w.l.o.g." in fact do lose generality.


More Natural Models of Electoral Control by Partition

  "Control" studies attempts to set the outcome of elections through the
addition, deletion, or partition of voters or candidates. The set of benchmark
control types was largely set in the seminal 1992 paper by Bartholdi, Tovey,
and Trick that introduced control, and there now is a large literature studying
how many of the benchmark types various election systems are vulnerable to,
i.e., have polynomial-time attack algorithms for.
  However, although the longstanding benchmark models of addition and deletion
model relatively well the real-world settings that inspire them, the
longstanding benchmark models of partition model settings that are arguably
quite distant from those they seek to capture.
  In this paper, we introduce--and for some important cases analyze the
complexity of--new partition models that seek to better capture many real-world
partition settings. In particular, in many partition settings one wants the two
parts of the partition to be of (almost) equal size, or is partitioning into
more than two parts, or has groups of actors who must be placed in the same
part of the partition. Our hope is that having these new partition types will
allow studies of control attacks to include such models that more realistically
capture many settings.


The Robustness of LWPP and WPP, with an Application to Graph
  Reconstruction

  We show that the counting class LWPP [FFK94] remains unchanged even if one
allows a polynomial number of gap values rather than one. On the other hand, we
show that it is impossible to improve this from polynomially many gap values to
a superpolynomial number of gap values by relativizable proof techniques.
  The first of these results implies that the Legitimate Deck Problem (from the
study of graph reconstruction) is in LWPP (and thus low for PP, i.e., $\rm
PP^{\mbox{Legitimate Deck}} = PP$) if the weakened version of the
Reconstruction Conjecture holds in which the number of nonisomorphic preimages
is assumed merely to be polynomially bounded. This strengthens the 1992 result
of K\"{o}bler, Sch\"{o}ning, and Tor\'{a}n [KST92] that the Legitimate Deck
Problem is in LWPP if the Reconstruction Conjecture holds, and provides
strengthened evidence that the Legitimate Deck Problem is not NP-hard.
  We additionally show on the one hand that our main LWPP robustness result
also holds for WPP, and also holds even when one allows both the rejection- and
acceptance- gap-value targets to simultaneously be polynomial-sized lists; yet
on the other hand, we show that for the #P-based analog of LWPP the behavior
much differs in that, in some relativized worlds, even two target values
already yield a richer class than one value does. Despite that nonrobustness
result for a #P-based class, we show that the #P-based "exact counting" class
$\rm C_{=}P$ remains unchanged even if one allows a polynomial number of target
values for the number of accepting paths of the machine.


Copeland Voting Fully Resists Constructive Control

  Control and bribery are settings in which an external agent seeks to
influence the outcome of an election. Faliszewski et al. [FHHR07] proved that
Llull voting (which is here denoted by Copeland^1) and a variant (here denoted
by Copeland^0) of Copeland voting are computationally resistant to many, yet
not all, types of constructive control and that they also provide broad
resistance to bribery. We study a parameterized version of Copeland voting,
denoted by Copeland^alpha where the parameter alpha is a rational number
between 0 and 1 that specifies how ties are valued in the pairwise comparisons
of candidates in Copeland elections. We establish resistance or vulnerability
results, in every previously studied control scenario, for Copeland^alpha, for
each rational alpha, 0 <alpha < 1. In particular, we prove that Copeland^0.5,
the system commonly referred to as ``Copeland voting,'' provides full
resistance to constructive control. Among the systems with a polynomial-time
winner problem, this is the first natural election system proven to have full
resistance to constructive control. Results on bribery and fixed-parameter
tractability of bounded-case control proven for Copeland^0 and Copeland^1 in
[FHHR07] are extended to Copeland^alpha for each rational alpha, 0 < alpha < 1;
we also give results in more flexible models such as microbribery and extended
control.


The Complexity of Online Manipulation of Sequential Elections

  Most work on manipulation assumes that all preferences are known to the
manipulators. However, in many settings elections are open and sequential, and
manipulators may know the already cast votes but may not know the future votes.
We introduce a framework, in which manipulators can see the past votes but not
the future ones, to model online coalitional manipulation of sequential
elections, and we show that in this setting manipulation can be extremely
complex even for election systems with simple winner problems. Yet we also show
that for some of the most important election systems such manipulation is
simple in certain settings. This suggests that when using sequential voting,
one should pay great attention to the details of the setting in choosing one's
voting rule.
  Among the highlights of our classifications are: We show that, depending on
the size of the manipulative coalition, the online manipulation problem can be
complete for each level of the polynomial hierarchy or even for PSPACE. We
obtain the most dramatic contrast to date between the nonunique-winner and
unique-winner models: Online weighted manipulation for plurality is in P in the
nonunique-winner model, yet is coNP-hard (constructive case) and NP-hard
(destructive case) in the unique-winner model. And we obtain what to the best
of our knowledge are the first PNP[1]-completeness and PNP-completeness results
in the field of computational social choice, in particular proving such
completeness for, respectively, the complexity of 3-candidate and 4-candidate
(and unlimited-candidate) online weighted coalition manipulation of veto
elections.


The Complexity of Online Voter Control in Sequential Elections

  Previous work on voter control, which refers to situations where a chair
seeks to change the outcome of an election by deleting, adding, or partitioning
voters, takes for granted that the chair knows all the voters' preferences and
that all votes are cast simultaneously. However, elections are often held
sequentially and the chair thus knows only the previously cast votes and not
the future ones, yet needs to decide instantaneously which control action to
take. We introduce a framework that models online voter control in sequential
elections. We show that the related problems can be much harder than in the
standard (non-online) case: For certain election systems, even with efficient
winner problems, online control by deleting, adding, or partitioning voters is
PSPACE-complete, even if there are only two candidates. In addition, we obtain
(by a new characterization of coNP in terms of weight-bounded alternating
Turing machines) completeness for coNP in the deleting/adding cases with a
bounded deletion/addition limit, and we obtain completeness for NP in the
partition cases with an additional restriction. We also show that for
plurality, online control by deleting or adding voters is in P, and for
partitioning voters is coNP-hard.


The Complexity of Boolean Constraint Isomorphism

  In 1978, Schaefer proved his famous dichotomy theorem for generalized
satisfiability problems. He defined an infinite number of propositional
satisfiability problems (nowadays usually called Boolean constraint
satisfaction problems) and showed that all these satisfiability problems are
either in P or NP-complete. In recent years, similar results have been obtained
for quite a few other problems for Boolean constraints.Almost all of these
problems are variations of the satisfiability problem.
  In this paper, we address a problem that is not a variation of
satisfiability, namely, the isomorphism problem for Boolean constraints.
Previous work by B\"ohler et al. showed that the isomorphism problem is either
coNP-hard or reducible to the graph isomorphism problem (a problem that is in
NP, but not known to be NP-hard), thus distinguishing a hard case and an easier
case. However, they did not classify which cases are truly easy, i.e., in P.
This paper accomplishes exactly that. It shows that Boolean constraint
isomorphism is coNP-hard (and GI-hard), or equivalent to graph isomorphism, or
in P, and it gives simple criteria to determine which case holds.


Generalized Modal Satisfiability

  It is well known that modal satisfiability is PSPACE-complete (Ladner 1977).
However, the complexity may decrease if we restrict the set of propositional
operators used. Note that there exist an infinite number of propositional
operators, since a propositional operator is simply a Boolean function. We
completely classify the complexity of modal satisfiability for every finite set
of propositional operators, i.e., in contrast to previous work, we classify an
infinite number of problems. We show that, depending on the set of
propositional operators, modal satisfiability is PSPACE-complete,
coNP-complete, or in P. We obtain this trichotomy not only for modal formulas,
but also for their more succinct representation using modal circuits. We
consider both the uni-modal and the multi-modal case, and study the dual
problem of validity as well.


Modeling Single-Peakedness for Votes with Ties

  Single-peakedness is one of the most important and well-known domain
restrictions on preferences. The computational study of single-peaked
electorates has largely been restricted to elections with tie-free votes, and
recent work that studies the computational complexity of manipulative attacks
for single-peaked elections for votes with ties has been restricted to
nonstandard models of single-peaked preferences for top orders. We study the
computational complexity of manipulation for votes with ties for the standard
model of single-peaked preferences and for single-plateaued preferences. We
show that these models avoid the anomalous complexity behavior exhibited by the
other models. We also state a surprising result on the relation between the
societal axis and the complexity of manipulation for single-peaked preferences.


Election Score Can Be Harder Than Winner

  Election systems based on scores generally determine the winner by computing
the score of each candidate and the winner is the candidate with the best
score. It would be natural to expect that computing the winner of an election
is at least as hard as computing the score of a candidate. We show that this is
not always the case. In particular, we show that for Young elections for
dichotomous preferences the winner problem is easy, while determining the score
of a candidate is hard. This complexity behavior has not been seen before and
is unusual. For example, a common slight variant of Young has a hard winner
problem for dichotomous preferences, and natural versions of Dodgson and Kemeny
for dichotomous preferences have easy score and winner problems.


Very Hard Electoral Control Problems

  It is important to understand how the outcome of an election can be modified
by an agent with control over the structure of the election. Electoral control
has been studied for many election systems, but for all studied systems the
winner problem is in P, and so control is in NP. There are election systems,
such as Kemeny, that have many desirable properties, but whose winner problems
are not in NP. Thus for such systems control is not in NP, and in fact we show
that it is typically complete for $\Sigma_2^p$ (i.e., ${\rm NP}^{\rm NP}$, the
second level of the polynomial hierarchy). This is a very high level of
complexity. Approaches that perform quite well for solving NP problems do not
necessarily work for $\Sigma_2^p$-complete problems. However, answer set
programming is suited to express problems in $\Sigma_2^p$, and we present an
encoding for Kemeny control.


The Complexity of Online Manipulation of Sequential Elections

  Most work on manipulation assumes that all preferences are known to the
manipulators. However, in many settings elections are open and sequential, and
manipulators may know the already cast votes but may not know the future votes.
We introduce a framework, in which manipulators can see the past votes but not
the future ones, to model online coalitional manipulation of sequential
elections, and we show that in this setting manipulation can be extremely
complex even for election systems with simple winner problems. Yet we also show
that for some of the most important election systems such manipulation is
simple in certain settings. This suggests that when using sequential voting,
one should pay great attention to the details of the setting in choosing one's
voting rule. Among the highlights of our classifications are: We show that,
depending on the size of the manipulative coalition, the online manipulation
problem can be complete for each level of the polynomial hierarchy or even for
PSPACE. We obtain the most dramatic contrast to date between the
nonunique-winner and unique-winner models: Online weighted manipulation for
plurality is in P in the nonunique-winner model, yet is coNP-hard (constructive
case) and NP-hard (destructive case) in the unique-winner model. And we obtain
what to the best of our knowledge are the first P^NP[1]-completeness and
P^NP-completeness results in the field of computational social choice, in
particular proving such completeness for, respectively, the complexity of
3-candidate and 4-candidate (and unlimited-candidate) online weighted coalition
manipulation of veto elections.


